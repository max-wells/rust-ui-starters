{
  "name": "p_tabs",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_tabs.rs",
      "content": "use leptos::{html::AnyElement, leptos_dom::helpers::AnimationFrameRequestHandle, *};\nuse web_sys::{FocusEvent, KeyboardEvent, MouseEvent};\n\nuse crate::registry::primitives::{\n    p_presence::create_presence,\n    p_primitive::Primitive,\n    p_roving_focus::{RovingFocusGroup, RovingFocusGroupItem},\n    p_utils_create_controllable_signal::{\n        create_controllable_signal, CreateControllableSignalProps,\n    },\n    p_utils_create_id::create_id,\n    Attributes, Direction, Orientation,\n};\n\n#[derive(Clone)]\nstruct TabsContextValue {\n    base_id: Signal<String>,\n    value: Signal<Option<String>>,\n    on_value_change: Callback<String>,\n    orientation: Signal<Orientation>,\n    direction: Signal<Direction>,\n    activation_mode: Signal<ActivationMode>,\n}\n\n#[derive(Clone, Default, PartialEq)]\npub enum ActivationMode {\n    #[default]\n    Automatic,\n    Manual,\n}\n\n#[component]\npub fn PrimitiveTabsRoot(\n    #[prop(optional, into)] value: MaybeProp<String>,\n    #[prop(optional, into)] default_value: MaybeProp<String>,\n    #[prop(optional, into)] orientation: MaybeSignal<Orientation>,\n    #[prop(optional, into)] direction: MaybeSignal<Direction>,\n    #[prop(optional, into)] activation_mode: MaybeSignal<ActivationMode>,\n    #[prop(default=(|_|{}).into(), into)] on_value_change: Callback<String>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let (value, set_value) = create_controllable_signal(CreateControllableSignalProps {\n        value: Signal::derive(move || value.get()),\n        default_value: Signal::derive(move || default_value.get()),\n        on_change: on_value_change,\n    });\n\n    provide_context(TabsContextValue {\n        base_id: create_id(),\n        value: Signal::derive(move || value.get()),\n        on_value_change: Callback::new(move |value| {\n            set_value.set(value);\n        }),\n        direction: Signal::derive(move || direction.get()),\n        orientation: Signal::derive(move || orientation.get()),\n        activation_mode: Signal::derive(move || activation_mode.get()),\n    });\n\n    view! {\n        <Primitive element=html::div node_ref=node_ref attrs=attrs as_child=as_child>\n            {children()}\n        </Primitive>\n    }\n}\n\n#[component]\npub fn PrimitiveTabsList(\n    #[prop(default=true.into(), into)] should_loop: MaybeSignal<bool>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let TabsContextValue {\n        orientation,\n        direction,\n        ..\n    } = use_context().expect(\"TabsList must be used in a TabsRoot component\");\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <RovingFocusGroup\n            as_child=true\n            orientation=Signal::derive(move || orientation.get())\n            direction=Signal::derive(move || direction.get())\n            should_loop=Signal::derive(move || should_loop.get())\n        >\n            <Primitive\n                {..attrs.clone()}\n                attr:role=\"tablist\"\n                attr:aria-orientation=move || orientation.get().to_string()\n                element=html::div\n                node_ref=node_ref\n                as_child=as_child\n            >\n                {children.with_value(|children| children())}\n            </Primitive>\n        </RovingFocusGroup>\n    }\n}\n\n#[component]\npub fn PrimitiveTabsTrigger(\n    #[prop(optional, into)] value: MaybeSignal<String>,\n    #[prop(optional, into)] disabled: MaybeSignal<bool>,\n    #[prop(default=(|_|{}).into(), into)] on_mouse_down: Callback<MouseEvent>,\n    #[prop(default=(|_|{}).into(), into)] on_key_down: Callback<KeyboardEvent>,\n    #[prop(default=(|_|{}).into(), into)] on_focus: Callback<FocusEvent>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let TabsContextValue {\n        base_id,\n        value: context_value,\n        on_value_change,\n        activation_mode,\n        ..\n    } = use_context().expect(\"TabsTrigger must be used in a TabsRoot component\");\n\n    let trigger_value = value.clone();\n    let trigger_id =\n        Signal::derive(move || format!(\"{}-trigger-{}\", base_id.get(), trigger_value.get()));\n\n    let content_value = value.clone();\n    let content_id =\n        Signal::derive(move || format!(\"{}-content-{}\", base_id.get(), content_value.get()));\n\n    let is_selected_value = value.clone();\n    let is_selected = Signal::derive(move || context_value.get() == Some(is_selected_value.get()));\n\n    let children = StoredValue::new(children);\n    let value = StoredValue::new(value);\n\n    view! {\n        <RovingFocusGroupItem\n            as_child=true\n            focusable=Signal::derive(move || !disabled.get())\n            active=is_selected\n        >\n            <Primitive\n                {..attrs.clone()}\n                attr:type=\"button\"\n                attr:role=\"tab\"\n                attr:aria-selected=is_selected\n                attr:aria-controls=content_id\n                attr:data-state=move || { if is_selected.get() { \"active\" } else { \"inactive\" } }\n                attr:data-disabled=move || disabled.get().then_some(\"\")\n                attr:disabled=disabled\n                attr:id=trigger_id\n                element=html::button\n                on:mousedown=move |ev: MouseEvent| {\n                    leptos::Callable::call(&on_mouse_down, ev.clone());\n                    if !disabled.get() && ev.button() == 0 && !ev.ctrl_key() {\n                        leptos::Callable::call(&on_value_change, value.get_value().get());\n                    } else {\n                        ev.prevent_default();\n                    }\n                }\n                on:keydown=move |ev: KeyboardEvent| {\n                    leptos::Callable::call(&on_key_down, ev.clone());\n                    if [\" \", \"Enter\"].contains(&ev.key().as_str()) {\n                        leptos::Callable::call(&on_value_change, value.get_value().get());\n                    }\n                }\n                on:focus=move |ev: FocusEvent| {\n                    leptos::Callable::call(&on_focus, ev.clone());\n                    let is_automatic_activation = activation_mode.get() != ActivationMode::Manual;\n                    if !is_selected.get() && !disabled.get() && is_automatic_activation {\n                        leptos::Callable::call(&on_value_change, value.get_value().get());\n                    }\n                }\n                node_ref=node_ref\n                as_child=as_child\n            >\n                {children.with_value(|children| children())}\n            </Primitive>\n        </RovingFocusGroupItem>\n    }\n}\n\n#[component]\npub fn PrimitiveTabsContent(\n    #[prop(optional, into)] value: MaybeSignal<String>,\n    #[prop(optional, into)] force_mount: MaybeSignal<bool>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let TabsContextValue {\n        base_id,\n        value: context_value,\n        orientation,\n        ..\n    } = use_context().expect(\"TabsContent must be used in a TabsRoot component\");\n\n    let trigger_value = value.clone();\n    let trigger_id =\n        Signal::derive(move || format!(\"{}-trigger-{}\", base_id.get(), trigger_value.get()));\n    let content_value = value.clone();\n    let content_id =\n        Signal::derive(move || format!(\"{}-content-{}\", base_id.get(), content_value.get()));\n\n    let is_selected_value = value.clone();\n    let is_selected = Signal::derive(move || context_value.get() == Some(is_selected_value.get()));\n    let is_mount_animation_prevented = StoredValue::new(is_selected.get_untracked());\n\n    let is_present = Signal::derive(move || is_selected.get() || force_mount.get());\n\n    let presence = create_presence(is_present, node_ref);\n    let animation_frame_handle = StoredValue::<Option<AnimationFrameRequestHandle>>::new(None);\n\n    Effect::new(move |_| {\n        if let Ok(handle) = request_animation_frame_with_handle(move || {\n            is_mount_animation_prevented.set_value(false);\n        }) {\n            animation_frame_handle.set_value(Some(handle));\n        }\n    });\n\n    on_cleanup(move || {\n        if let Some(handle) = animation_frame_handle.get_value() {\n            handle.cancel();\n        }\n    });\n\n    Effect::new(move |_| {\n        let Some(node) = node_ref.get() else {\n            return;\n        };\n\n        _ = presence.get();\n\n        if is_mount_animation_prevented.get_value() {\n            _ = node.style(\"animation-duration\", \"0s\");\n        }\n    });\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <Show when=move || presence.get()>\n            <Primitive\n                {..attrs.clone()}\n                attr:role=\"tabpanel\"\n                attr:data-state=move || { if is_selected.get() { \"active\" } else { \"inactive\" } }\n                attr:data-orientation=move || orientation.get().to_string()\n                attr:aria-labelledby=trigger_id\n                attr:hidden=move || !is_present.get()\n                attr:id=content_id\n                attr:tabindex=0\n                element=html::div\n                node_ref=node_ref\n                as_child=as_child\n            >\n                {children.with_value(|children| children())}\n            </Primitive>\n        </Show>\n    }\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
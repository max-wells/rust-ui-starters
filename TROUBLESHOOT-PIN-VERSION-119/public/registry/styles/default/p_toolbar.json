{
  "name": "p_toolbar",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_toolbar.rs",
      "content": "use leptos::{html::AnyElement, Callable, *};\nuse wasm_bindgen::JsCast;\nuse web_sys::{HtmlAnchorElement, KeyboardEvent};\n\nuse crate::{\n    registry::primitives::{\n        p_primitive::Primitive,\n        p_roving_focus::{RovingFocusGroup, RovingFocusGroupItem},\n        p_separator::PrimitiveSeparatorRoot,\n        p_toggle_group::{ToggleGroupItem, ToggleGroupRoot},\n        Attributes,\n    },\n    registry::primitives::{Direction, Orientation},\n};\n\nuse super::p_toggle_group::ToggleGroupKind;\n\n#[derive(Clone)]\nstruct ToolbarContextValue {\n    orientation: Signal<Orientation>,\n    direction: Signal<Direction>,\n}\n\n#[component]\npub fn ToolbarRoot(\n    #[prop(optional, into)] orientation: MaybeSignal<Orientation>,\n    #[prop(optional, into)] direction: MaybeSignal<Direction>,\n    #[prop(default=true.into(), into)] should_loop: MaybeSignal<bool>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    provide_context(ToolbarContextValue {\n        orientation: Signal::derive(move || orientation.get()),\n        direction: Signal::derive(move || direction.get()),\n    });\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <RovingFocusGroup\n            orientation=Signal::derive(move || orientation.get())\n            direction=Signal::derive(move || direction.get())\n            should_loop=Signal::derive(move || should_loop.get())\n        >\n            <Primitive\n                {..attrs.clone()}\n                attr:role=\"toolbar\"\n                attr:aria-orientation=move || orientation.get().to_string()\n                attr:dir=move || direction.get().to_string()\n                element=html::div\n                node_ref=node_ref\n                as_child=as_child\n            >\n                {children.with_value(|children| children())}\n            </Primitive>\n        </RovingFocusGroup>\n    }\n}\n\n#[component]\npub fn ToolbarSeparator(\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    #[prop(optional)] children: Option<ChildrenFn>,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let ToolbarContextValue {\n        orientation, ..\n    } = use_context().expect(\"ToolbarSeparator must be used in a ToolbarRoot component\");\n\n    let orientation = Signal::derive(move || match orientation.get() {\n        Orientation::Horizontal => Orientation::Vertical,\n        Orientation::Vertical => Orientation::Horizontal,\n    });\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <PrimitiveSeparatorRoot\n            orientation=orientation\n            node_ref=node_ref\n            attrs=attrs\n            as_child=as_child\n        >\n            {children.with_value(|children| children.as_ref().map(|children| children()))}\n        </PrimitiveSeparatorRoot>\n    }\n}\n\n#[component]\npub fn ToolbarButton(\n    #[prop(optional, into)] disabled: MaybeSignal<bool>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let children = StoredValue::new(children);\n\n    view! {\n        <RovingFocusGroupItem as_child=true focusable=Signal::derive(move || disabled.get())>\n            <Primitive\n                {..attrs.clone()}\n                attr:type=\"button\"\n                element=html::button\n                node_ref=node_ref\n                as_child=as_child\n            >\n                {children.with_value(|children| children())}\n            </Primitive>\n        </RovingFocusGroupItem>\n    }\n}\n\n#[component]\npub fn ToolbarLink(\n    #[prop(default=(|_|{}).into(), into)] on_key_down: Callback<KeyboardEvent>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let children = StoredValue::new(children);\n\n    view! {\n        <RovingFocusGroupItem as_child=true focusable=true>\n            <Primitive\n                element=html::a\n                node_ref=node_ref\n                attrs=attrs.clone()\n                as_child=as_child\n                on:keydown=move |ev: KeyboardEvent| {\n                    Callable::call(&on_key_down, ev.clone());\n                    if ev.key() == \" \" {\n                        if let Some(current_target) = ev.current_target() {\n                            if let Some(current_target) = current_target\n                                .dyn_ref::<HtmlAnchorElement>()\n                            {\n                                current_target.click();\n                            }\n                        }\n                    }\n                }\n            >\n                {children.with_value(|children| children())}\n            </Primitive>\n        </RovingFocusGroupItem>\n    }\n}\n\n#[component]\npub fn ToolbarToggleGroup(\n    kind: ToggleGroupKind,\n    #[prop(optional, into)] disabled: MaybeSignal<bool>,\n    #[prop(optional, into)] orientation: MaybeSignal<Orientation>,\n    #[prop(optional, into)] direction: MaybeSignal<Direction>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<ToolbarContextValue>()\n        .expect(\"ToolbarToggleGroup must be in a ToolbarRoot component\");\n\n    view! {\n        <ToggleGroupRoot\n            {..attrs}\n            attr:data-orientation=move || context.orientation.get().to_string()\n            attr:dir=move || context.direction.get().to_string()\n            kind=kind\n            disabled=Signal::derive(move || disabled.get())\n            orientation=Signal::derive(move || orientation.get())\n            direction=Signal::derive(move || direction.get())\n            roving_focus=false\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </ToggleGroupRoot>\n    }\n}\n\n#[component]\npub fn ToolbarToggleItem(\n    #[prop(optional, into)] disabled: MaybeSignal<bool>,\n    #[prop(into)] value: MaybeSignal<String>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let children = StoredValue::new(children);\n\n    view! {\n        <ToolbarButton as_child=true>\n            <ToggleGroupItem\n                disabled=Signal::derive(move || disabled.get())\n                value=value.clone()\n                node_ref=node_ref\n                attrs=attrs.clone()\n                as_child=as_child\n            >\n                {children.with_value(|children| children())}\n            </ToggleGroupItem>\n        </ToolbarButton>\n    }\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
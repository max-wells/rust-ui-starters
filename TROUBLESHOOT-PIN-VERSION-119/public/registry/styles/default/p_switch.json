{
  "name": "p_switch",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_switch.rs",
      "content": "use leptos::{\n    html::{AnyElement, Input},\n    *,\n};\nuse leptos_use::{use_element_size, UseElementSizeReturn};\nuse wasm_bindgen::{JsCast, JsValue};\nuse web_sys::{\n    js_sys::{Array, Function, JsString, Object, Reflect},\n    Event, EventInit, MouseEvent,\n};\n\nuse crate::registry::primitives::{\n    p_primitive::Primitive,\n    p_utils_create_controllable_signal::{\n        create_controllable_signal, CreateControllableSignalProps,\n    },\n    p_utils_create_previous::create_previous,\n    Attributes,\n};\n\n#[derive(Clone)]\nstruct SwitchContextValue {\n    checked: Signal<bool>,\n    disabled: Signal<bool>,\n}\n\n#[allow(unused_variables)]\n#[component]\npub fn PrimitiveSwitchRoot(\n    #[prop(optional, into)] checked: MaybeProp<bool>,\n    #[prop(optional, into)] default_checked: MaybeProp<bool>,\n    #[prop(optional, into)] value: MaybeProp<String>,\n    #[prop(optional, into)] name: MaybeProp<String>,\n    #[prop(optional, into)] disabled: MaybeSignal<bool>,\n    #[prop(optional, into)] required: MaybeSignal<bool>,\n    #[prop(default=(|_|{}).into(), into)] on_checked_change: Callback<bool>,\n    #[prop(default=(|_|{}).into(), into)] on_click: Callback<MouseEvent>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let node_ref = NodeRef::<AnyElement>::new();\n    let (is_form_control, set_is_form_control) = create_signal(true);\n\n    let has_consumer_stopped_propagation = StoredValue::new(false);\n\n    let (checked, set_checked) = create_controllable_signal(CreateControllableSignalProps {\n        value: Signal::derive(move || checked.get()),\n        default_value: Signal::derive(move || default_checked.get()),\n        on_change: on_checked_change,\n    });\n\n    Effect::new(move |_| {\n        set_is_form_control.set(if let Some(node) = node_ref.get() {\n            node.closest(\"form\").ok().flatten().is_some()\n        } else {\n            true\n        });\n    });\n\n    provide_context(SwitchContextValue {\n        checked: Signal::derive(move || checked.get().unwrap_or(false)),\n        disabled: Signal::derive(move || disabled.get()),\n    });\n\n    let attr_value = value.clone();\n\n    view! {\n        <Primitive\n            {..attrs}\n            attr:type=\"button\"\n            attr:role=\"switch\"\n            attr:aria-checked=checked\n            attr:aria-required=required\n            attr:data-state=move || {\n                if checked.get().unwrap_or(false) { \"checked\" } else { \"unchecked\" }\n            }\n            attr:data-disabled=disabled\n            attr:value=attr_value\n            element=html::button\n            on:click=move |ev: MouseEvent| {\n                leptos::Callable::call(&on_click, ev.clone());\n                set_checked.update(|checked| *checked = Some(!checked.unwrap_or(false)));\n                if is_form_control.get() && !has_consumer_stopped_propagation.get_value() {\n                    ev.stop_propagation();\n                }\n            }\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </Primitive>\n\n        <Show when=move || is_form_control.get()>\n            <PrimitiveBubbleInput\n                checked=Signal::derive(move || checked.get().unwrap_or(false))\n                bubbles=Signal::derive(move || !has_consumer_stopped_propagation.get_value())\n                name=name.clone()\n                value=value.clone()\n                disabled=Signal::derive(move || disabled.get())\n                required=Signal::derive(move || required.get())\n                control=node_ref\n            />\n        </Show>\n    }\n}\n\n#[component]\npub fn PrimitiveSwitchThumb(\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    #[prop(optional)] children: Option<ChildrenFn>,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let SwitchContextValue {\n        checked,\n        disabled,\n    } = use_context().expect(\"SwitchThumb must be used in a SwitchRoot component\");\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <Primitive\n            {..attrs}\n            attr:data-state=move || { if checked.get() { \"checked\" } else { \"unchecked\" } }\n            attr:data-disabled=move || disabled.get().then_some(\"\")\n            element=html::span\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children.with_value(|children| children.as_ref().map(|children| children()))}\n        </Primitive>\n    }\n}\n\n#[component]\npub fn PrimitiveBubbleInput(\n    checked: Signal<bool>,\n    bubbles: Signal<bool>,\n    #[prop(into)] name: MaybeProp<String>,\n    #[prop(into)] value: MaybeProp<String>,\n    disabled: Signal<bool>,\n    required: Signal<bool>,\n    control: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n) -> impl IntoView {\n    let node_ref = NodeRef::<Input>::new();\n    let prev_checked = create_previous(Signal::derive(move || checked.get()));\n    let UseElementSizeReturn {\n        width,\n        height,\n    } = use_element_size(control);\n\n    Effect::new(move |_| {\n        (|| {\n            let input = node_ref.get()?;\n            let input_el = window().get(\"HTMLInputElement\")?;\n            let input_proto = Reflect::get(&input_el, &JsString::from(\"prototype\"))\n                .ok()?\n                .dyn_into::<Object>()\n                .ok()?;\n\n            let input_descriptor_set = Reflect::get(\n                &Object::get_own_property_descriptor(&input_proto, &JsString::from(\"checked\")),\n                &JsString::from(\"set\"),\n            )\n            .ok()?\n            .dyn_into::<Function>()\n            .ok()?;\n\n            if prev_checked.get() != checked.get() {\n                let ev_options = EventInit::new();\n                ev_options.set_bubbles(bubbles.get());\n\n                let ev = Event::new_with_event_init_dict(\"click\", &ev_options).ok()?;\n\n                _ = Reflect::apply(\n                    &input_descriptor_set,\n                    &input,\n                    &Array::from_iter([JsValue::from_bool(checked.get())]),\n                );\n\n                _ = input.dispatch_event(&ev);\n            }\n\n            Some(())\n        })();\n    });\n\n    view! {\n        <input\n            type=\"checkbox\"\n            aria-hidden\n            checked=Signal::derive(move || checked.get()).into_attribute()\n            tabindex=(-1).into_attribute()\n            node_ref=node_ref\n            name=name.into_attribute()\n            value=Signal::derive(move || value.get().unwrap_or(\"on\".into())).into_attribute()\n            disabled=Signal::derive(move || disabled.get()).into_attribute()\n            required=Signal::derive(move || required.get()).into_attribute()\n            style:position=\"absolute\"\n            style:pointer-events=\"none\"\n            style:opacity=\"0\"\n            style:margin=\"0\"\n            style:width=move || width.get()\n            style:height=move || height.get()\n            {..attrs}\n        />\n    }\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
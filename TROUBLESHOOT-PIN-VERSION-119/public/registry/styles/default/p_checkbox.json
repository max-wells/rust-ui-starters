{
  "name": "p_checkbox",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_checkbox.rs",
      "content": "use leptos::{\n    html::{AnyElement, Input},\n    *,\n};\n\nuse leptos_use::{use_element_size, UseElementSizeReturn};\nuse wasm_bindgen::{closure::Closure, JsCast, JsValue};\nuse web_sys::{\n    js_sys::{Array, Function, JsString, Object, Reflect},\n    Event, EventInit, HtmlButtonElement, KeyboardEvent, MouseEvent,\n};\n\nuse crate::registry::primitives::{\n    p_presence::create_presence,\n    p_primitive::Primitive,\n    p_utils_create_controllable_signal::{\n        create_controllable_signal, CreateControllableSignalProps,\n    },\n    p_utils_create_previous::create_previous,\n    Attributes,\n};\n\n#[derive(Clone, Copy, Debug, PartialEq)]\npub enum CheckedState {\n    Checked(bool),\n    Indeterminate,\n}\n\n#[derive(Clone)]\nstruct CheckboxValueContext {\n    state: Signal<CheckedState>,\n    disabled: Signal<bool>,\n}\n\n#[component]\npub fn PrimitiveCheckboxRoot(\n    #[prop(optional, into)] required: MaybeSignal<bool>,\n    #[prop(optional, into)] disabled: MaybeSignal<bool>,\n    #[prop(optional, into)] checked: MaybeProp<CheckedState>,\n    #[prop(optional, into)] default_checked: MaybeProp<CheckedState>,\n    #[prop(default=(|_|{}).into(), into)] on_checked_change: Callback<CheckedState>,\n    #[prop(default=(|_|{}).into(), into)] on_click: Callback<MouseEvent>,\n    #[prop(default=(|_|{}).into(), into)] on_key_down: Callback<KeyboardEvent>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let _has_consumer_stropped_propagation = StoredValue::new(false);\n\n    let (is_form_control, set_is_form_control) = create_signal(true);\n\n    let (checked, set_checked) = create_controllable_signal(CreateControllableSignalProps {\n        value: Signal::derive(move || checked.get()),\n        default_value: Signal::derive(move || default_checked.get()),\n        on_change: Callback::new(move |value| {\n            leptos::Callable::call(&on_checked_change, value);\n        }),\n    });\n\n    let initial_checked_state = StoredValue::new(checked.get_untracked());\n\n    Effect::new(move |_| {\n        let Some(node) = node_ref.get() else {\n            return;\n        };\n\n        let Some(button) = node.dyn_ref::<HtmlButtonElement>() else {\n            return;\n        };\n\n        let Some(form) = button.form() else {\n            return;\n        };\n\n        let reset_set_checked = set_checked;\n        let reset = Closure::<dyn FnMut()>::new(move || {\n            reset_set_checked.set(\n                initial_checked_state\n                    .get_value()\n                    .unwrap_or(CheckedState::Checked(false)),\n            );\n        });\n\n        _ = form.add_event_listener_with_callback(\"reset\", reset.as_ref().unchecked_ref());\n\n        on_cleanup(move || {\n            _ = form.remove_event_listener_with_callback(\"reset\", reset.as_ref().unchecked_ref());\n\n            reset.forget();\n        });\n    });\n\n    Effect::new(move |_| {\n        set_is_form_control.set(if let Some(node) = node_ref.get() {\n            node.closest(\"form\").ok().flatten().is_some()\n        } else {\n            true\n        });\n    });\n\n    provide_context(CheckboxValueContext {\n        state: Signal::derive(move || checked.get().unwrap_or(CheckedState::Checked(false))),\n        disabled: Signal::derive(move || disabled.get()),\n    });\n\n    let bubble_ref = NodeRef::<Input>::new();\n\n    Effect::new(move |_| {\n        let Some(node) = bubble_ref.get() else {\n            return;\n        };\n\n        _ = node.style(\"transform\", \"translateX(-100%)\");\n    });\n\n    view! {\n        <Primitive\n            {..attrs}\n            element=html::button\n            attr:type=\"button\"\n            attr:role=\"checkbox\"\n            attr:aria-checked=move || {\n                checked\n                    .get()\n                    .map(|checked| match checked {\n                        CheckedState::Checked(checked) => checked.into_attribute(),\n                        CheckedState::Indeterminate => \"mixed\".into_attribute(),\n                    })\n            }\n            attr:aria-required=required\n            attr:data-state=move || {\n                checked\n                    .get()\n                    .map(|checked| match checked {\n                        CheckedState::Checked(checked) => {\n                            if checked { \"checked\" } else { \"unchecked\" }\n                        }\n                        CheckedState::Indeterminate => \"indeterminate\",\n                    })\n            }\n            attr:data-disabled=disabled\n            attr:disabled=disabled\n            on:keydown=move |ev: KeyboardEvent| {\n                leptos::Callable::call(&on_key_down, ev.clone());\n                if ev.key() == \"Enter\" {\n                    ev.prevent_default();\n                }\n            }\n            on:click=move |ev: MouseEvent| {\n                leptos::Callable::call(&on_click, ev.clone());\n                set_checked\n                    .update(|checked| {\n                        *checked = Some(\n                            match checked.as_ref().unwrap_or(&CheckedState::Checked(false)) {\n                                CheckedState::Checked(checked) => CheckedState::Checked(!checked),\n                                CheckedState::Indeterminate => CheckedState::Checked(true),\n                            },\n                        );\n                    });\n                if is_form_control.get() {\n                    ev.stop_propagation();\n                }\n            }\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </Primitive>\n        <Show when=move || is_form_control.get()>\n            <PrimitiveBubbleInput\n                checked=Signal::derive(move || {\n                    checked.get().unwrap_or(CheckedState::Checked(false))\n                })\n                bubbles=Signal::derive(move || false)\n                control=node_ref\n                node_ref=bubble_ref\n            />\n        </Show>\n    }\n}\n\n#[component]\npub fn PrimitiveCheckboxIndicator(\n    #[prop(optional, into)] force_mount: MaybeSignal<bool>,\n\n    #[prop(attrs)] attrs: Attributes,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let CheckboxValueContext {\n        state,\n        disabled,\n    } = use_context::<CheckboxValueContext>()\n        .expect(\"CheckboxIndicator must be used inside of a CheckboxRoot component\");\n\n    let is_present =\n        Signal::derive(move || force_mount.get() || state.get() != CheckedState::Checked(false));\n\n    let presence = create_presence(is_present, node_ref);\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <Show when=move || presence.get()>\n            <Primitive\n                {..attrs.clone()}\n                attr:data-state=move || match state.get() {\n                    CheckedState::Checked(checked) => if checked { \"checked\" } else { \"unchecked\" }\n                    CheckedState::Indeterminate => \"indeterminate\",\n                }\n                attr:disabled=disabled\n                element=html::span\n                node_ref=node_ref\n                as_child=as_child\n            >\n                {children.with_value(|children| children())}\n            </Primitive>\n        </Show>\n    }\n}\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                     ✨ FUNCTIONS ✨                        */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n#[component]\nfn PrimitiveBubbleInput(\n    checked: Signal<CheckedState>,\n    control: NodeRef<AnyElement>,\n    bubbles: Signal<bool>,\n\n    node_ref: NodeRef<Input>,\n    #[prop(attrs)] attrs: Attributes,\n) -> impl IntoView {\n    let prev_checked = create_previous(Signal::derive(move || checked.get()));\n    let UseElementSizeReturn {\n        width,\n        height,\n    } = use_element_size(control);\n\n    Effect::new(move |_| {\n        (|| {\n            let input = node_ref.get()?;\n            let input_el = window().get(\"HTMLInputElement\")?;\n            let input_proto = Reflect::get(&input_el, &JsString::from(\"prototype\"))\n                .ok()?\n                .dyn_into::<Object>()\n                .ok()?;\n\n            let input_descriptor_set = Reflect::get(\n                &Object::get_own_property_descriptor(&input_proto, &JsString::from(\"checked\")),\n                &JsString::from(\"set\"),\n            )\n            .ok()?\n            .dyn_into::<Function>()\n            .ok()?;\n\n            if prev_checked.get() != checked.get() {\n                let ev_options = EventInit::new();\n                ev_options.set_bubbles(bubbles.get());\n\n                let ev = Event::new_with_event_init_dict(\"click\", &ev_options).ok()?;\n\n                _ = Reflect::set(\n                    &input,\n                    &JsString::from(\"indeterminate\"),\n                    &JsValue::from_bool(checked.get() == CheckedState::Indeterminate),\n                );\n\n                _ = Reflect::apply(\n                    &input_descriptor_set,\n                    &input,\n                    &Array::from_iter([JsValue::from_bool(match checked.get() {\n                        CheckedState::Indeterminate => false,\n                        CheckedState::Checked(checked) => checked,\n                    })]),\n                );\n\n                _ = input.dispatch_event(&ev);\n            }\n\n            Some(())\n        })();\n    });\n\n    view! {\n        <input\n            {..attrs}\n            type=\"checkbox\"\n            aria-hidden=\"true\"\n            checked=(move || match checked.get() {\n                CheckedState::Checked(checked) => checked,\n                CheckedState::Indeterminate => false,\n            })\n                .into_attribute()\n            tabindex=(-1).into_attribute()\n            node_ref=node_ref\n            style:position=\"absolute\"\n            style:pointer-events=\"none\"\n            style:opacity=\"0\"\n            style:margin=\"0\"\n            style:width=move || format!(\"{}px\", width.get())\n            style:height=move || format!(\"{}px\", height.get())\n        />\n    }\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
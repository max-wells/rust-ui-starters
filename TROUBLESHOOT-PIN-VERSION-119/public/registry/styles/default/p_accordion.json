{
  "name": "p_accordion",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_accordion.rs",
      "content": "use leptos::{html::AnyElement, *};\nuse std::collections::HashMap;\nuse wasm_bindgen::JsCast;\nuse web_sys::KeyboardEvent;\n\nuse crate::registry::primitives::{\n    p_collapsible::{\n        PrimitiveCollapsibleContent, PrimitiveCollapsibleRoot, PrimitiveCollapsibleTrigger,\n    },\n    p_collection::{use_collection_context, use_collection_item_ref},\n    p_primitive::Primitive,\n    p_utils_create_controllable_signal::{\n        create_controllable_signal, CreateControllableSignalProps,\n    },\n    p_utils_create_id::create_id,\n    Attributes, Direction, Orientation,\n};\n\nuse super::p_collection::CollectionContextValue;\n\npub enum AccordionKind {\n    Single {\n        value: MaybeProp<String>,\n        default_value: MaybeProp<String>,\n        on_value_change: Option<Callback<String>>,\n        collapsible: MaybeSignal<bool>,\n    },\n    Multiple {\n        value: MaybeProp<Vec<String>>,\n        default_value: MaybeProp<Vec<String>>,\n        on_value_change: Option<Callback<Vec<String>>>,\n    },\n}\n\npub struct AccordionSingle;\npub struct AccordionMultiple;\n\nimpl AccordionSingle {\n    pub fn none() -> Option<String> {\n        None\n    }\n}\n\nimpl AccordionMultiple {\n    pub fn none() -> Option<Vec<String>> {\n        None\n    }\n}\n\n#[derive(Clone)]\nstruct AccordionContextValue {\n    value: Signal<Vec<String>>,\n    on_item_open: Callback<String>,\n    on_item_close: Callback<String>,\n}\n\n#[derive(Clone)]\nstruct AccordionCollapsibleContextValue {\n    collapsible: MaybeSignal<bool>,\n}\n\n#[component]\npub fn PrimitiveAccordionRoot(\n    kind: AccordionKind,\n    #[prop(optional, into)] disabled: MaybeSignal<bool>,\n    #[prop(optional, into)] direction: MaybeSignal<Direction>,\n    #[prop(default=Orientation::Vertical.into(), into)] orientation: MaybeSignal<Orientation>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    provide_context(\n        CollectionContextValue::<AccordionCollectionItem, AnyElement> {\n            collection_ref: node_ref,\n            item_map: RwSignal::new(HashMap::new()),\n        },\n    );\n\n    match kind {\n        AccordionKind::Single {\n            value,\n            default_value,\n            on_value_change,\n            collapsible,\n        } => view! {\n            <PrimitiveAccordionSingleImpl\n                value=value\n                default_value=default_value\n                on_value_change=on_value_change.unwrap_or((|_| {}).into())\n                collapsible=Signal::derive(move || collapsible.get())\n                disabled=Signal::derive(move || disabled.get())\n                direction=Signal::derive(move || direction.get())\n                orientation=Signal::derive(move || orientation.get())\n                node_ref=node_ref\n                attrs=attrs\n                as_child=as_child\n            >\n                {children()}\n            </PrimitiveAccordionSingleImpl>\n        },\n        AccordionKind::Multiple {\n            value,\n            default_value,\n            on_value_change,\n        } => view! {\n            <PrimitiveAccordionMultipleImpl\n                value=value\n                default_value=default_value\n                on_value_change=on_value_change.unwrap_or((|_| {}).into())\n                disabled=Signal::derive(move || disabled.get())\n                direction=Signal::derive(move || direction.get())\n                orientation=Signal::derive(move || orientation.get())\n                node_ref=node_ref\n                attrs=attrs\n                as_child=as_child\n            >\n                {children()}\n            </PrimitiveAccordionMultipleImpl>\n        },\n    }\n}\n\n#[component]\nfn PrimitiveAccordionSingleImpl(\n    #[prop(optional, into)] value: MaybeProp<String>,\n    #[prop(optional, into)] default_value: MaybeProp<String>,\n\n    on_value_change: Callback<String>,\n\n    collapsible: Signal<bool>,\n    disabled: Signal<bool>,\n    direction: Signal<Direction>,\n    orientation: Signal<Orientation>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let (value, set_value) = create_controllable_signal(CreateControllableSignalProps {\n        value: Signal::derive(move || value.get()),\n        default_value: Signal::derive(move || default_value.get()),\n        on_change: Callback::new(move |value| {\n            leptos::Callable::call(&on_value_change, value);\n        }),\n    });\n\n    let set_on_item_open = set_value.clone();\n    let set_on_item_close = set_value.clone();\n\n    provide_context(AccordionContextValue {\n        value: Signal::derive(move || value.get().map(|value| vec![value]).unwrap_or_default()),\n        on_item_open: Callback::new(move |value| {\n            set_on_item_open.set(value);\n        }),\n        on_item_close: Callback::new(move |_| {\n            if collapsible.get() {\n                set_on_item_close.set(String::new());\n            }\n        }),\n    });\n\n    provide_context(AccordionCollapsibleContextValue {\n        collapsible: Signal::derive(move || collapsible.get()).into(),\n    });\n\n    view! {\n        <PrimitiveAccordion\n            disabled=disabled\n            direction=direction\n            orientation=orientation\n            node_ref=node_ref\n            attrs=attrs\n            as_child=as_child\n        >\n            {children()}\n        </PrimitiveAccordion>\n    }\n}\n\n#[component]\nfn PrimitiveAccordionMultipleImpl(\n    #[prop(optional)] value: MaybeProp<Vec<String>>,\n    #[prop(optional)] default_value: MaybeProp<Vec<String>>,\n    on_value_change: Callback<Vec<String>>,\n    disabled: Signal<bool>,\n    direction: Signal<Direction>,\n    orientation: Signal<Orientation>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let (value, set_value) = create_controllable_signal(CreateControllableSignalProps {\n        value: Signal::derive(move || value.get()),\n        default_value: Signal::derive(move || default_value.get()),\n        on_change: Callback::new(move |value| {\n            leptos::Callable::call(&on_value_change, value);\n        }),\n    });\n\n    let set_on_item_open = set_value.clone();\n    let set_on_item_close = set_value.clone();\n\n    provide_context(AccordionContextValue {\n        value: Signal::derive(move || value.get().unwrap_or_default()),\n        on_item_open: Callback::new(move |value| {\n            set_on_item_open.update(|prev| {\n                if let Some(prev) = prev {\n                    prev.push(value);\n                } else {\n                    *prev = Some(vec![]);\n                }\n            });\n        }),\n        on_item_close: Callback::new(move |value| {\n            set_on_item_close.update(|prev| {\n                if let Some(prev) = prev {\n                    if let Some(position) = prev.iter().position(|prev_value| prev_value.eq(&value))\n                    {\n                        prev.remove(position);\n                    }\n                } else {\n                    *prev = Some(vec![]);\n                }\n            });\n        }),\n    });\n\n    provide_context(AccordionCollapsibleContextValue {\n        collapsible: true.into(),\n    });\n\n    view! {\n        <PrimitiveAccordion\n            disabled=disabled\n            direction=direction\n            orientation=orientation\n            node_ref=node_ref\n            attrs=attrs\n            as_child=as_child\n        >\n            {children()}\n        </PrimitiveAccordion>\n    }\n}\n\n#[derive(Clone)]\nstruct AccordionStateContextValue {\n    disabled: Signal<bool>,\n    orientation: Signal<Orientation>,\n    // direction: Signal<Direction>,\n}\n\n#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord)]\nstruct AccordionCollectionItem;\n\n#[component]\nfn PrimitiveAccordion(\n    disabled: Signal<bool>,\n    orientation: Signal<Orientation>,\n    direction: Signal<Direction>,\n    #[prop(default=(|_|{}).into(), into)] on_key_down: Callback<KeyboardEvent>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let get_items = use_collection_context::<AccordionCollectionItem, AnyElement>();\n\n    let is_direction_left_to_right =\n        Signal::derive(move || direction.get() == Direction::LeftToRight);\n\n    provide_context(AccordionStateContextValue {\n        disabled: Signal::derive(move || disabled.get()),\n        orientation: Signal::derive(move || orientation.get()),\n        // direction: Signal::derive(move || direction.get()),\n    });\n\n    view! {\n        <Primitive\n            {..attrs}\n            attr:data-orientation=move || orientation.get().to_string()\n            element=html::div\n            on:keydown=move |ev: KeyboardEvent| {\n                leptos::Callable::call(&on_key_down, ev.clone());\n                if !disabled.get() {\n                    return;\n                }\n                (|| {\n                    let target = ev.target()?;\n                    let target_el = target.dyn_ref::<web_sys::HtmlButtonElement>()?;\n                    let items = get_items.get();\n                    let triggers = items\n                        .iter()\n                        .filter_map(|(node, _)| {\n                            let node = node.get()?;\n                            let node = node.dyn_ref::<web_sys::HtmlButtonElement>()?;\n                            Some((!node.disabled()).then_some(node.clone())).flatten()\n                        })\n                        .collect::<Vec<_>>();\n                    let trigger_index = triggers.iter().position(|item| item.eq(target_el))?;\n                    let trigger_count = triggers.len();\n                    ev.prevent_default();\n                    let mut next_index = trigger_index;\n                    let home_index = 0;\n                    let end_index = 0;\n                    match ev.key().as_str() {\n                        \"Home\" => {\n                            next_index = home_index;\n                        }\n                        \"End\" => {\n                            next_index = end_index;\n                        }\n                        \"ArrowRight\" => {\n                            if orientation.get() == Orientation::Horizontal {\n                                if is_direction_left_to_right.get() {\n                                    next_index = trigger_index + 1;\n                                    if next_index > end_index {\n                                        next_index = home_index;\n                                    }\n                                } else {\n                                    next_index = trigger_index - 1;\n                                    if next_index < home_index {\n                                        next_index = end_index;\n                                    }\n                                }\n                            }\n                        }\n                        \"ArrowDown\" => {\n                            if orientation.get() == Orientation::Vertical {\n                                next_index = trigger_index + 1;\n                                if next_index > end_index {\n                                    next_index = home_index;\n                                }\n                            }\n                        }\n                        \"ArrowLeft\" => {\n                            if orientation.get() == Orientation::Horizontal {\n                                if is_direction_left_to_right.get() {\n                                    next_index = trigger_index - 1;\n                                    if next_index < home_index {\n                                        next_index = end_index;\n                                    }\n                                } else {\n                                    next_index = trigger_index + 1;\n                                    if next_index > end_index {\n                                        next_index = home_index;\n                                    }\n                                }\n                            }\n                        }\n                        \"ArrowUp\" => {\n                            if orientation.get() == Orientation::Vertical {\n                                next_index = trigger_index - 1;\n                                if next_index < home_index {\n                                    next_index = end_index;\n                                }\n                            }\n                        }\n                        _ => {}\n                    }\n                    let clamped_index = next_index % trigger_count;\n                    if let Some(trigger) = triggers.get(clamped_index) {\n                        _ = trigger.focus();\n                    }\n                    Some(())\n                })();\n            }\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </Primitive>\n    }\n}\n\n#[derive(Clone)]\nstruct AccordionItemContextValue {\n    open: Signal<bool>,\n    disabled: Signal<bool>,\n    trigger_id: Signal<String>,\n}\n\n#[component]\npub fn PrimitiveAccordionItem(\n    #[prop(optional, into)] disabled: MaybeSignal<bool>,\n    #[prop(into)] value: MaybeSignal<String>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let state_context = use_context::<AccordionStateContextValue>()\n        .expect(\"AccordionItem must be in an Accordion component\");\n    let value_context = use_context::<AccordionContextValue>()\n        .expect(\"AccordionItem must be in an AccordionRoot component\");\n\n    let trigger_id = create_id();\n    let is_open_value = value.clone();\n    let is_open = Signal::derive(move || {\n        value_context\n            .value\n            .get()\n            .iter()\n            .any(|item| (*item).eq(&is_open_value.get()) && !is_open_value.get().is_empty())\n    });\n    let is_disabled = Signal::derive(move || state_context.disabled.get() || disabled.get());\n\n    provide_context(AccordionItemContextValue {\n        open: Signal::derive(move || is_open.get()),\n        disabled: Signal::derive(move || is_disabled.get()),\n        trigger_id: Signal::derive(move || trigger_id.get()),\n    });\n\n    let open_value = value.clone();\n    view! {\n        <PrimitiveCollapsibleRoot\n            {..attrs}\n            attr:data-orientation=move || state_context.orientation.get().to_string()\n            attr:data-state=move || if is_open.get() { \"open\" } else { \"closed\" }\n            attr:data-disabled=disabled\n            open=is_open\n            disabled=is_disabled\n            on_open_change=Callback::new(move |open| {\n                if open {\n                    leptos::Callable::call(&value_context.on_item_open, open_value.get());\n                } else {\n                    leptos::Callable::call(&value_context.on_item_close, open_value.get());\n                }\n            })\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </PrimitiveCollapsibleRoot>\n    }\n}\n\n#[component]\npub fn PrimitiveAccordionHeader(\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let AccordionStateContextValue {\n        orientation, ..\n    } = use_context().expect(\"AccordionHeader must be in an Accordion component\");\n    let AccordionItemContextValue {\n        open,\n        disabled,\n        ..\n    } = use_context().expect(\"AccordionHeader must be in an AccordionRoot component\");\n\n    view! {\n        <Primitive\n            {..attrs}\n            attr:data-orientation=move || orientation.get().to_string()\n            attr:data-state=move || if open.get() { \"open\" } else { \"closed\" }\n            attr:data-disabled=disabled\n            element=html::h3\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </Primitive>\n    }\n}\n\n#[component]\npub fn PrimitiveAccordionTrigger(\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let AccordionStateContextValue {\n        orientation, ..\n    } = use_context().expect(\"AccordionTrigger must be in an Accordion component\");\n    let AccordionItemContextValue {\n        trigger_id,\n        open,\n        ..\n    } = use_context().expect(\"AccordionTrigger must be in an AccordionRoot component\");\n    let AccordionCollapsibleContextValue {\n        collapsible,\n    } = use_context().expect(\"AccordionTrigger must be in an AccordionRoot component\");\n\n    use_collection_item_ref(node_ref, AccordionCollectionItem);\n\n    view! {\n        <PrimitiveCollapsibleTrigger\n            {..attrs}\n            attr:data-orientation=move || orientation.get().to_string()\n            attr:id=trigger_id\n            attr:aria-disabled=move || open.get() && !collapsible.get()\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </PrimitiveCollapsibleTrigger>\n    }\n}\n\n#[component]\npub fn PrimitiveAccordionContent(\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let AccordionStateContextValue {\n        orientation, ..\n    } = use_context().expect(\"AccordionTrigger must be in an Accordion component\");\n    let AccordionItemContextValue {\n        trigger_id, ..\n    } = use_context().expect(\"AccordionTrigger must be in an AccordionRoot component\");\n\n    Effect::new(move |_| {\n        let Some(node) = node_ref.get() else {\n            return;\n        };\n\n        _ = node\n            .style(\n                \"--primitive-accordion-content-width\",\n                \"var(--primitive-collapsible-content-width)\",\n            )\n            .style(\n                \"--primitive-accordion-content-height\",\n                \"var(--primitive-collapsible-content-height)\",\n            );\n    });\n\n    view! {\n        <PrimitiveCollapsibleContent\n            {..attrs}\n            attr:data-orientation=move || orientation.get().to_string()\n            attr:aria-labelledby=trigger_id\n            attr:role=\"region\"\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </PrimitiveCollapsibleContent>\n    }\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
{
  "name": "p_collection",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_collection.rs",
      "content": "use std::collections::HashMap;\n\nuse leptos::{html::ElementDescriptor, *};\nuse web_sys::js_sys::Array;\n\n#[derive(Clone)]\npub struct CollectionContextValue<\n    ItemData: Clone + Ord + 'static,\n    ItemElement: ElementDescriptor + Clone + 'static,\n> {\n    pub(crate) collection_ref: NodeRef<ItemElement>,\n    pub(crate) item_map: RwSignal<HashMap<CollectionItemId, (NodeRef<ItemElement>, ItemData)>>,\n}\n\nuse derive_more::Deref;\n\n#[derive(Deref, Clone, PartialEq, Eq, Hash)]\npub struct CollectionItemId(String);\n\nimpl CollectionItemId {\n    fn new() -> Self {\n        Self(nanoid::nanoid!())\n    }\n}\n\npub fn use_collection_item_ref<\n    ItemElement: ElementDescriptor + Clone + 'static,\n    ItemData: Clone + Ord + 'static,\n>(\n    item_ref: NodeRef<ItemElement>,\n    data: ItemData,\n) -> NodeRef<ItemElement> {\n    let CollectionContextValue {\n        item_map, ..\n    } = use_context::<CollectionContextValue<ItemData, ItemElement>>().expect(\n        \"create_collection_item_ref must be used in a component that provides a collection context\",\n    );\n\n    let (id, set_id) = create_signal::<Option<CollectionItemId>>(None);\n    //let item_ref = NodeRef::<ItemElement>::new();\n\n    Effect::new(move |_| {\n        if let Some(node) = item_ref.get() {\n            let id = CollectionItemId::new();\n\n            _ = node.attr(\n                \"data-primitive-collection-item\",\n                id.0.clone().into_attribute(),\n            );\n\n            set_id.set(Some(id));\n        }\n    });\n\n    Effect::new(move |_| {\n        let Some(id) = id.get() else {\n            return;\n        };\n\n        item_map.update(|item_map| {\n            item_map.insert(id.clone(), (item_ref, data.clone()));\n        });\n    });\n\n    on_cleanup(move || {\n        let Some(id) = id.get() else {\n            return;\n        };\n\n        _ = item_map.try_update(|item_map| {\n            item_map.remove(&id.clone());\n        });\n    });\n\n    item_ref\n}\n\npub fn use_collection_context<\n    ItemData: Clone + Ord + std::fmt::Debug + 'static,\n    ItemElement: ElementDescriptor + Clone + 'static,\n>() -> Signal<Vec<(NodeRef<ItemElement>, ItemData)>> {\n    let CollectionContextValue {\n        collection_ref,\n        item_map,\n    } = use_context::<CollectionContextValue<ItemData, ItemElement>>().expect(\n        \"use_collection_context must be used in a component that provides a collection context\",\n    );\n\n    Signal::derive(move || {\n        let Some(collection_node) = collection_ref.get() else {\n            return vec![];\n        };\n\n        let el = collection_node.into_any();\n\n        if el.is_null() {\n            return vec![];\n        }\n\n        let Ok(ordered_nodes) = el.query_selector_all(\"[data-primitive-collection-item]\") else {\n            return vec![];\n        };\n\n        let ordered_nodes = Array::from(&ordered_nodes);\n\n        let items = item_map.get();\n        let mut sorted_items = items.into_values().collect::<Vec<_>>();\n\n        sorted_items.sort_by(|curr, next| {\n            ordered_nodes\n                .index_of(&curr.0.get().unwrap().into_any(), 0)\n                .cmp(&ordered_nodes.index_of(&next.0.get().unwrap().into_any(), 0))\n        });\n\n        sorted_items\n    })\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
{
  "name": "p_slider",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_slider.rs",
      "content": "use leptos::{\n    ev::focus,\n    html::{AnyElement, Input, Span},\n    *,\n};\nuse leptos_use::use_element_size;\nuse std::collections::HashMap;\nuse strum::EnumString;\nuse wasm_bindgen::{JsCast, JsValue};\nuse web_sys::{\n    js_sys::{Array, Function, JsString, Object, Reflect},\n    DomRect, Event, EventInit, KeyboardEvent, PointerEvent,\n};\n\nuse crate::registry::primitives::{\n    linear_scale,\n    p_collection::{use_collection_context, use_collection_item_ref, CollectionContextValue},\n    p_primitive::Primitive,\n    p_utils_create_controllable_signal::{\n        create_controllable_signal, CreateControllableSignalProps,\n    },\n    p_utils_create_previous::create_previous,\n    Attributes, Direction, Orientation,\n};\n\n#[derive(Clone)]\nstruct SliderContextValue {\n    name: Signal<Option<String>>,\n    disabled: Signal<bool>,\n    min: Signal<f64>,\n    max: Signal<f64>,\n    values: Signal<Vec<f64>>,\n    value_index_to_change: StoredValue<Option<usize>>,\n    thumbs: StoredValue<Vec<HtmlElement<AnyElement>>>,\n    orientation: Signal<Orientation>,\n}\n\n#[component]\npub fn PrimitiveSliderRoot(\n    #[prop(optional, into)] name: MaybeProp<String>,\n    #[prop(default=0.0f64.into(), into)] min: MaybeSignal<f64>,\n    #[prop(default=100.0f64.into(), into)] max: MaybeSignal<f64>,\n    #[prop(default=1.0f64.into(), into)] step: MaybeSignal<f64>,\n    #[prop(optional, into)] orientation: MaybeSignal<Orientation>,\n    #[prop(optional, into)] direction: MaybeSignal<Direction>,\n    #[prop(optional, into)] disabled: MaybeSignal<bool>,\n    #[prop(default=0.0f64.into(), into)] min_steps_between_thumbs: MaybeSignal<f64>,\n    #[prop(optional, into)] value: MaybeProp<Vec<f64>>,\n    #[prop(optional, into)] default_value: MaybeProp<Vec<f64>>,\n    #[prop(optional, into)] inverted: MaybeSignal<bool>,\n\n    #[prop(default=(|_|{}).into(), into)] on_value_change: Callback<Vec<f64>>,\n    #[prop(default=(|_|{}).into(), into)] on_value_commit: Callback<Vec<f64>>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let thumbs = StoredValue::new(Vec::<HtmlElement<AnyElement>>::new());\n    let value_index_to_change = StoredValue::new(Some(0usize));\n\n    let (values, set_values) = create_controllable_signal(CreateControllableSignalProps {\n        value: Signal::derive(move || value.get()),\n        default_value: Signal::derive(move || Some(default_value.get().unwrap_or(vec![min.get()]))),\n        on_change: Callback::new(move |value| {\n            let thumbs = thumbs.get_value();\n            let thumbs = Vec::from_iter(thumbs.iter());\n\n            if let Some(value_index) = value_index_to_change.get_value() {\n                if let Some(thumb) = thumbs.get(value_index) {\n                    _ = thumb.focus();\n                }\n            }\n\n            leptos::Callable::call(&on_value_change, value);\n        }),\n    });\n\n    let values = Signal::derive(move || values.get().unwrap_or_default());\n    let values_before_slide_start = StoredValue::new(values.get_untracked());\n\n    let update_values = move |value: f64, at_index: usize, commit: bool| {\n        let decimal_count = get_decimal_count(step.get());\n        let snap_to_step = round_value(\n            ((value - min.get()) / step.get()).round() * step.get() + min.get(),\n            decimal_count as u32,\n        );\n        let next_value = snap_to_step.clamp(min.get(), max.get());\n\n        set_values.update(move |values| {\n            let previous_values = values.as_ref().cloned().unwrap_or_default();\n            let next_values = get_next_sorted_values(&previous_values, next_value, at_index);\n\n            if has_min_steps_between_values(\n                &next_values,\n                min_steps_between_thumbs.get() * step.get(),\n            ) {\n                value_index_to_change\n                    .set_value(next_values.iter().position(|value| value == &next_value));\n\n                let updated_count = next_values\n                    .iter()\n                    .zip(previous_values.iter())\n                    .filter(|&(prev, curr)| prev == curr)\n                    .count();\n\n                let has_changed =\n                    updated_count != next_values.len() || updated_count != previous_values.len();\n\n                if has_changed {\n                    if commit {\n                        leptos::Callable::call(&on_value_commit, next_values.clone());\n                    }\n\n                    *values = Some(next_values);\n                }\n            }\n        });\n    };\n\n    let start_update = update_values.clone();\n    let handle_slide_start = Callback::new(move |value: f64| {\n        if let Some(closest_index) = find_closest_index(&values.get(), value) {\n            start_update(value, closest_index, false);\n        }\n    });\n\n    let move_update = update_values.clone();\n    let handle_slide_move = Callback::new(move |value: f64| {\n        if let Some(value_index) = value_index_to_change.get_value() {\n            move_update(value, value_index, false);\n        }\n    });\n\n    let handle_slide_end = Callback::new(move |_: ()| {\n        let prev_value = value_index_to_change\n            .get_value()\n            .and_then(|index| values_before_slide_start.get_value().get(index).cloned());\n\n        let next_value = value_index_to_change\n            .get_value()\n            .and_then(|index| values.get().get(index).cloned());\n\n        let has_changed = next_value != prev_value;\n\n        if has_changed {\n            leptos::Callable::call(&on_value_commit, values.get());\n        }\n    });\n\n    provide_context(SliderContextValue {\n        name: Signal::derive(move || name.get()),\n        disabled: Signal::derive(move || disabled.get()),\n        min: Signal::derive(move || min.get()),\n        max: Signal::derive(move || max.get()),\n        value_index_to_change,\n        thumbs,\n        values: Signal::derive(move || values.get()),\n        orientation: Signal::derive(move || orientation.get()),\n    });\n\n    provide_context(CollectionContextValue::<SliderCollectionItem, AnyElement> {\n        collection_ref: node_ref,\n        item_map: RwSignal::new(HashMap::new()),\n    });\n\n    let home_key_down_update = update_values.clone();\n    let end_key_down_update = update_values.clone();\n\n    view! {\n        <PrimitiveSlider\n            {..attrs}\n            attr:aria-disabled=disabled\n            attr:data-disabled=move || disabled.get().then_some(\"\")\n            min=Signal::derive(move || min.get())\n            max=Signal::derive(move || max.get())\n            inverted=Signal::derive(move || inverted.get())\n            direction=Signal::derive(move || direction.get())\n            orientation=Signal::derive(move || orientation.get())\n            on_slide_start=handle_slide_start\n            on_slide_move=handle_slide_move\n            on_slide_end=handle_slide_end\n            on_home_key_down=Callback::new(move |_| {\n                if !disabled.get() {\n                    home_key_down_update(min.get(), 0, true);\n                }\n            })\n            on_end_key_down=Callback::new(move |_| {\n                if !disabled.get() {\n                    end_key_down_update(max.get(), values.get().len() - 1, true);\n                }\n            })\n            on_step_key_down=Callback::new(move |Step { event, direction }| {\n                if disabled.get() {\n                    return;\n                }\n                let is_page_key = [\"PageUp\", \"PageDown\"].contains(&event.key().as_str());\n                let is_skip_key = is_page_key\n                    || (event.shift_key()\n                        && [\"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"ArrowDown\"]\n                            .contains(&event.key().as_str()));\n                let multiplier = if is_skip_key { 10.0f64 } else { 1.0f64 };\n                let Some(at_index) = value_index_to_change.get_value() else {\n                    return;\n                };\n                let value = values.get().get(at_index).cloned().unwrap_or(0.);\n                let step_in_direction = step.get() * multiplier\n                    * match direction {\n                        OrientationDirection::Forward => 1.0f64,\n                        OrientationDirection::Backward => -1.0f64,\n                    };\n                update_values(value + step_in_direction, at_index, true);\n            })\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </PrimitiveSlider>\n    }\n}\n\n#[derive(Clone, PartialEq, EnumString, strum::Display, strum::IntoStaticStr)]\nenum Side {\n    Top,\n    Right,\n    Bottom,\n    Left,\n}\n\n#[derive(Clone, PartialEq)]\nenum OrientationDirection {\n    Forward,\n    Backward,\n}\n\n#[derive(Clone)]\nenum Size {\n    Width,\n    Height,\n}\n\n#[derive(Clone)]\nstruct OrientationContextValue {\n    start_edge: Signal<Side>,\n    end_edge: Signal<Side>,\n    size: Signal<Size>,\n    direction: Signal<OrientationDirection>,\n}\n\nstruct Step {\n    event: KeyboardEvent,\n    direction: OrientationDirection,\n}\n\n#[allow(clippy::enum_variant_names)]\n#[derive(Clone)]\nenum SlideDirection {\n    FromLeft,\n    FromRight,\n    FromBottom,\n    FromTop,\n}\n\n#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord)]\nstruct SliderCollectionItem;\n\n#[derive(Clone)]\nstruct SliderImplContextValue {\n    dom_rect: StoredValue<Option<DomRect>>,\n}\n\n#[component]\nfn PrimitiveSlider(\n    max: Signal<f64>,\n    min: Signal<f64>,\n    inverted: Signal<bool>,\n    orientation: Signal<Orientation>,\n    direction: Signal<Direction>,\n\n    on_slide_start: Callback<f64>,\n    on_slide_move: Callback<f64>,\n    on_slide_end: Callback<()>,\n    on_home_key_down: Callback<KeyboardEvent>,\n    on_end_key_down: Callback<KeyboardEvent>,\n    on_step_key_down: Callback<Step>,\n\n    #[prop(attrs)] attrs: Attributes,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let dom_rect = StoredValue::<Option<DomRect>>::new(None);\n\n    provide_context(SliderImplContextValue {\n        dom_rect,\n    });\n\n    let children = StoredValue::new(children);\n\n    move || {\n        let attrs = attrs.clone();\n\n        match orientation.get() {\n            Orientation::Horizontal => view! {\n                <PrimitiveSliderHorizontal\n                    max=max\n                    min=min\n                    inverted=inverted\n                    direction=direction\n                    node_ref=node_ref\n                >\n                    <SliderImpl\n                        max=max\n                        min=min\n                        inverted=inverted\n                        orientation=orientation\n                        direction=direction\n                        on_slide_start=on_slide_start\n                        on_slide_move=on_slide_move\n                        on_slide_end=on_slide_end\n                        on_home_key_down=on_home_key_down\n                        on_end_key_down=on_end_key_down\n                        on_step_key_down=on_step_key_down\n                        node_ref=node_ref\n                        attrs=attrs\n                        as_child=as_child\n                    >\n                        {children.with_value(|children| children())}\n                    </SliderImpl>\n                </PrimitiveSliderHorizontal>\n            },\n            Orientation::Vertical => view! {\n                <PrimitiveSliderVertical\n                    max=max\n                    min=min\n                    inverted=inverted\n                    direction=direction\n                    node_ref=node_ref\n                >\n                    <SliderImpl\n                        max=max\n                        min=min\n                        inverted=inverted\n                        orientation=orientation\n                        direction=direction\n                        on_slide_start=on_slide_start\n                        on_slide_move=on_slide_move\n                        on_slide_end=on_slide_end\n                        on_home_key_down=on_home_key_down\n                        on_end_key_down=on_end_key_down\n                        on_step_key_down=on_step_key_down\n                        node_ref=node_ref\n                        attrs=attrs\n                        as_child=as_child\n                    >\n                        {children.with_value(|children| children())}\n                    </SliderImpl>\n                </PrimitiveSliderVertical>\n            },\n        }\n    }\n}\n\n#[derive(Clone)]\nstruct SliderOrientationImplContextValue {\n    pointer_value: Callback<i32, f64>,\n    slide_direction: Signal<SlideDirection>,\n}\n\n#[component]\nfn PrimitiveSliderHorizontal(\n    max: Signal<f64>,\n    min: Signal<f64>,\n    inverted: Signal<bool>,\n    direction: Signal<Direction>,\n    node_ref: NodeRef<AnyElement>,\n    children: Children,\n) -> impl IntoView {\n    let SliderImplContextValue {\n        dom_rect,\n    } = use_context().expect(\"SliderImpl must be used in a Slider component\");\n\n    let is_left_to_right = Signal::derive(move || direction.get() == Direction::LeftToRight);\n    let is_sliding_from_left = Signal::derive(move || {\n        (is_left_to_right.get() && !inverted.get()) || (!is_left_to_right.get() && inverted.get())\n    });\n\n    let pointer_value = Callback::new(move |pointer: i32| {\n        let rect = dom_rect\n            .get_value()\n            .unwrap_or(node_ref.get().unwrap().get_bounding_client_rect());\n\n        let input = (0., rect.width());\n        let output = if is_sliding_from_left.get() {\n            (min.get(), max.get())\n        } else {\n            (max.get(), min.get())\n        };\n        let value = linear_scale(input, output);\n\n        dom_rect.set_value(Some(rect.clone()));\n\n        value(pointer as f64 - rect.left())\n    });\n\n    let slide_direction = Signal::derive(move || {\n        if is_sliding_from_left.get() {\n            SlideDirection::FromLeft\n        } else {\n            SlideDirection::FromRight\n        }\n    });\n\n    provide_context(OrientationContextValue {\n        start_edge: Signal::derive(move || {\n            if is_sliding_from_left.get() {\n                Side::Left\n            } else {\n                Side::Right\n            }\n        }),\n        end_edge: Signal::derive(move || {\n            if is_sliding_from_left.get() {\n                Side::Right\n            } else {\n                Side::Left\n            }\n        }),\n        direction: Signal::derive(move || {\n            if is_sliding_from_left.get() {\n                OrientationDirection::Forward\n            } else {\n                OrientationDirection::Backward\n            }\n        }),\n        size: Signal::derive(|| Size::Width),\n    });\n\n    provide_context(SliderOrientationImplContextValue {\n        pointer_value,\n        slide_direction,\n    });\n\n    view! { <>{children()}</> }\n}\n\n#[allow(unused_variables)]\n#[component]\nfn PrimitiveSliderVertical(\n    max: Signal<f64>,\n    min: Signal<f64>,\n    inverted: Signal<bool>,\n    direction: Signal<Direction>,\n    node_ref: NodeRef<AnyElement>,\n    children: Children,\n) -> impl IntoView {\n    let SliderImplContextValue {\n        dom_rect,\n    } = use_context().expect(\"SliderImpl must be used in a Slider component\");\n\n    let is_sliding_from_bottom = Signal::derive(move || !inverted.get());\n\n    let pointer_value = Callback::new(move |pointer: i32| {\n        let rect = dom_rect\n            .get_value()\n            .unwrap_or(node_ref.get().unwrap().get_bounding_client_rect());\n\n        let input = (0., rect.height());\n        let output = if is_sliding_from_bottom.get() {\n            (max.get(), min.get())\n        } else {\n            (min.get(), max.get())\n        };\n        let value = linear_scale(input, output);\n\n        dom_rect.set_value(Some(rect.clone()));\n\n        value(pointer as f64 - rect.top())\n    });\n\n    let slide_direction = Signal::derive(move || {\n        if is_sliding_from_bottom.get() {\n            SlideDirection::FromBottom\n        } else {\n            SlideDirection::FromTop\n        }\n    });\n\n    provide_context(OrientationContextValue {\n        start_edge: Signal::derive(move || {\n            if is_sliding_from_bottom.get() {\n                Side::Bottom\n            } else {\n                Side::Top\n            }\n        }),\n        end_edge: Signal::derive(move || {\n            if is_sliding_from_bottom.get() {\n                Side::Top\n            } else {\n                Side::Bottom\n            }\n        }),\n        direction: Signal::derive(move || {\n            if is_sliding_from_bottom.get() {\n                OrientationDirection::Forward\n            } else {\n                OrientationDirection::Backward\n            }\n        }),\n        size: Signal::derive(|| Size::Height),\n    });\n\n    provide_context(SliderOrientationImplContextValue {\n        pointer_value,\n        slide_direction,\n    });\n\n    children().into_view()\n}\n\n#[allow(unused_variables)]\n#[component]\nfn SliderImpl(\n    max: Signal<f64>,\n    min: Signal<f64>,\n    inverted: Signal<bool>,\n    orientation: Signal<Orientation>,\n    direction: Signal<Direction>,\n    on_slide_start: Callback<f64>,\n    on_slide_move: Callback<f64>,\n    on_slide_end: Callback<()>,\n    on_home_key_down: Callback<KeyboardEvent>,\n    on_end_key_down: Callback<KeyboardEvent>,\n    on_step_key_down: Callback<Step>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let SliderImplContextValue {\n        dom_rect,\n    } = use_context().expect(\"SliderImpl must be used in a Slider component\");\n\n    let SliderOrientationImplContextValue {\n        pointer_value,\n        slide_direction,\n    } = use_context()\n        .expect(\"SliderImpl must be used in either a SliderHorizontal or SliderVertical component\");\n\n    let context =\n        use_context::<SliderContextValue>().expect(\"Slider must be used in a SliderRoot component\");\n\n    Effect::new(move |_| {\n        if let Some(node) = node_ref.get() {\n            _ = node.style(\n                \"--primitive-slider-thumb-transform\",\n                if orientation.get() == Orientation::Vertical {\n                    \"translateY(50%)\"\n                } else {\n                    \"translateX(-50%)\"\n                },\n            );\n        }\n    });\n\n    view! {\n        <Primitive\n            {..attrs}\n            attr:data-orientation=move || orientation.get().to_string()\n            attr:dir=move || {\n                (orientation.get() == Orientation::Horizontal)\n                    .then_some(direction.get().to_string())\n            }\n            element=html::span\n            on:keydown=move |ev: KeyboardEvent| {\n                if ev.key() == \"Home\" {\n                    leptos::Callable::call(&on_home_key_down, ev.clone());\n                } else if ev.key() == \"End\" {\n                    leptos::Callable::call(&on_end_key_down, ev.clone());\n                } else if [\"PageUp\", \"PageDown\", \"ArrowLeft\", \"ArrowRight\", \"ArrowUp\", \"ArrowDown\"]\n                    .contains(&ev.key().as_ref())\n                {\n                    let is_back_key = match slide_direction.get() {\n                        SlideDirection::FromLeft => {\n                            [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"]\n                                .contains(&ev.key().as_ref())\n                        }\n                        SlideDirection::FromRight => {\n                            [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowRight\"]\n                                .contains(&ev.key().as_ref())\n                        }\n                        SlideDirection::FromTop => {\n                            [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"]\n                                .contains(&ev.key().as_ref())\n                        }\n                        SlideDirection::FromBottom => {\n                            [\"Home\", \"PageDown\", \"ArrowUp\", \"ArrowLeft\"]\n                                .contains(&ev.key().as_ref())\n                        }\n                    };\n                    leptos::Callable::call(\n                        &on_step_key_down,\n                        Step {\n                            event: ev.clone(),\n                            direction: if is_back_key {\n                                OrientationDirection::Backward\n                            } else {\n                                OrientationDirection::Forward\n                            },\n                        },\n                    );\n                } else {\n                    return;\n                }\n                ev.prevent_default();\n            }\n            on:pointerdown=move |ev: PointerEvent| {\n                let Some(target) = ev.target() else {\n                    return;\n                };\n                let Some(target_el) = target.dyn_ref::<web_sys::HtmlElement>() else {\n                    return;\n                };\n                _ = target_el.set_pointer_capture(ev.pointer_id());\n                ev.prevent_default();\n                if context\n                    .thumbs\n                    .get_value()\n                    .iter()\n                    .any(|el| {\n                        let el: &web_sys::HtmlElement = el;\n                        el == target_el\n                    })\n                {\n                    _ = target_el.focus();\n                }\n                leptos::Callable::call(&on_slide_start, pointer_value.call(ev.client_x()));\n            }\n            on:pointermove=move |ev: PointerEvent| {\n                let Some(target) = ev.target() else {\n                    return;\n                };\n                let Some(target_el) = target.dyn_ref::<web_sys::HtmlElement>() else {\n                    return;\n                };\n                if target_el.has_pointer_capture(ev.pointer_id()) {\n                    leptos::Callable::call(\n                        &on_slide_move,\n                        leptos::Callable::call(\n                            &pointer_value,\n                            if orientation.get() == Orientation::Horizontal {\n                                ev.client_x()\n                            } else {\n                                ev.client_y()\n                            },\n                        ),\n                    );\n                }\n            }\n            on:pointerup=move |ev: PointerEvent| {\n                let Some(target) = ev.target() else {\n                    return;\n                };\n                let Some(target_el) = target.dyn_ref::<web_sys::HtmlElement>() else {\n                    return;\n                };\n                if target_el.has_pointer_capture(ev.pointer_id()) {\n                    _ = target_el.release_pointer_capture(ev.pointer_id());\n                    dom_rect.set_value(None);\n                    leptos::Callable::call(&on_slide_end, ());\n                }\n            }\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </Primitive>\n    }\n}\n\n#[component]\npub fn SliderTrack(\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let SliderContextValue {\n        disabled,\n        orientation,\n        ..\n    } = use_context().expect(\"SliderTrack must be used in a SliderRoot component\");\n\n    view! {\n        <Primitive\n            {..attrs}\n            attr:data-disabled=move || disabled.get().then_some(\"\")\n            attr:data-orientation=move || orientation.get().to_string()\n            element=html::span\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </Primitive>\n    }\n}\n\n#[component]\npub fn PrimitiveSliderRange(\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<SliderContextValue>()\n        .expect(\"SliderRange must be used in a SliderRoot component\");\n    let orientation = use_context::<OrientationContextValue>()\n        .expect(\"SliderRange must be used in a SliderRoot component\");\n\n    let value_count = Signal::derive(move || context.values.get().len());\n    let percentages = Signal::derive(move || {\n        context\n            .values\n            .get()\n            .iter()\n            .map(|value| convert_value_to_percentage(*value, context.min.get(), context.max.get()))\n            .collect::<Vec<_>>()\n    });\n\n    let offset_start = Signal::derive(move || {\n        if value_count.get() > 1 {\n            percentages\n                .get()\n                .iter()\n                .fold(f64::INFINITY, |min, &x| min.min(x))\n        } else {\n            0.0f64\n        }\n    });\n    let offset_end = Signal::derive(move || {\n        100.0f64\n            - percentages\n                .get()\n                .iter()\n                .fold(f64::NEG_INFINITY, |max, &x| max.max(x))\n    });\n\n    Effect::new(move |_| {\n        if let Some(node) = node_ref.get() {\n            _ = node\n                .style(\n                    orientation.start_edge.get().to_string().to_lowercase(),\n                    format!(\"{}%\", offset_start.get()),\n                )\n                .style(\n                    orientation.end_edge.get().to_string().to_lowercase(),\n                    format!(\"{}%\", offset_end.get()),\n                );\n        }\n    });\n\n    view! {\n        <Primitive\n            {..attrs}\n            attr:data-disabled=move || context.disabled.get().then_some(\"\")\n            attr:data-orientation=move || context.orientation.get().to_string()\n            element=html::span\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </Primitive>\n    }\n}\n\n#[component]\npub fn PrimitiveSliderThumb(\n    #[prop(optional, into)] name: MaybeProp<String>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    use_collection_item_ref::<html::AnyElement, SliderCollectionItem>(\n        node_ref,\n        SliderCollectionItem,\n    );\n    let get_items = use_collection_context::<SliderCollectionItem, AnyElement>();\n\n    let context = use_context::<SliderContextValue>()\n        .expect(\"SliderThumb must be used in a SliderRoot component\");\n    let orientation = use_context::<OrientationContextValue>()\n        .expect(\"SliderThumb must be used in a SliderRoot component\");\n\n    let (is_form_control, set_is_form_control) = create_signal(true);\n\n    let size = use_element_size(node_ref);\n\n    let index = Signal::derive(move || {\n        let node = node_ref.get()?;\n        let items = get_items.get();\n\n        let index = items.iter().position(|item| {\n            let Some(item) = item.0.get() else {\n                return false;\n            };\n\n            let item_el: &web_sys::Element = &item;\n            let node_el: &web_sys::Element = &node;\n\n            item_el == node_el\n        })?;\n\n        Some(index)\n    });\n\n    let value = Signal::derive(move || {\n        let result = *context.values.get().get(index.get()?)?;\n        Some(result)\n    });\n\n    let percent = Signal::derive(move || {\n        value\n            .get()\n            .map(|value| convert_value_to_percentage(value, context.min.get(), context.max.get()))\n            .unwrap_or(0.)\n    });\n\n    let _label = Signal::derive(move || {\n        index\n            .get()\n            .and_then(|index| get_label(index, context.values.get().len()))\n    });\n\n    let orientation_size = Signal::derive(move || match orientation.size.get() {\n        Size::Width => size.width.get(),\n        Size::Height => size.height.get(),\n    });\n\n    let thumbs_in_bound_offset = Signal::derive(move || {\n        get_thumb_in_bounds_offset(\n            orientation_size.get(),\n            percent.get(),\n            match orientation.direction.get() {\n                OrientationDirection::Backward => -1.0f64,\n                OrientationDirection::Forward => 1.0f64,\n            },\n        )\n    });\n\n    Effect::new(move |_| {\n        set_is_form_control.set(if let Some(node) = node_ref.get() {\n            node.closest(\"form\").ok().flatten().is_some()\n        } else {\n            true\n        });\n    });\n\n    Effect::new(move |_| {\n        let Some(node) = node_ref.get() else {\n            return;\n        };\n\n        context.thumbs.update_value(|thumbs| {\n            thumbs.push(node.clone());\n        });\n\n        on_cleanup(move || {\n            // let Some(node) = node_ref.get() else {\n            //   return;\n            // };\n\n            _ = context.thumbs.try_update_value(|thumbs| {\n                if let Some(position) = thumbs.iter().position(|thumb| {\n                    let thumb_el: &web_sys::Element = thumb;\n                    let node_el: &web_sys::Element = &node.clone();\n\n                    thumb_el == node_el\n                }) {\n                    _ = thumbs.remove(position);\n                }\n            });\n        });\n    });\n\n    Effect::new(move |_| {\n        let Some(node) = node_ref.get() else {\n            return;\n        };\n\n        let node = node.on(focus, move |_| {\n            context.value_index_to_change.set_value(index.get());\n        });\n\n        if value.get().is_none() {\n            _ = node.clone().style(\"display\", \"none\");\n        }\n    });\n\n    let span_ref = NodeRef::<Span>::new();\n\n    Effect::new(move |_| {\n        if let Some(node) = span_ref.get() {\n            _ = node.style(\n                orientation.start_edge.get().to_string().to_lowercase(),\n                format!(\n                    \"calc({}% + {}px)\",\n                    percent.get(),\n                    thumbs_in_bound_offset.get()\n                ),\n            );\n        }\n    });\n\n    view! {\n        <span\n            style:transform=\"var(--primitive-slider-thumb-transform)\"\n            style:position=\"absolute\"\n            node_ref=span_ref\n        >\n            <Primitive\n                {..attrs}\n                attr:role=\"slider\"\n                attr:aria-label=name.clone()\n                attr:aria-valuemin=context.min\n                attr:aria-valuenow=move || value.get().unwrap_or_default()\n                attr:aria-valuemax=context.max\n                attr:aria-orientation=move || context.orientation.get().to_string()\n                attr:data-orientation=move || context.orientation.get().to_string()\n                attr:data-disabled=move || context.disabled.get().then_some(\"\")\n                attr:tabindex=move || (!context.disabled.get()).then_some(0)\n                element=html::span\n                node_ref=node_ref\n                as_child=as_child\n            >\n                {children()}\n            </Primitive>\n\n            <Show when=move || is_form_control.get()>\n                <PrimitiveBubbleInput\n                    name=name.clone()\n                    value=Signal::derive(move || value.get().unwrap_or_default())\n                />\n            </Show>\n        </span>\n    }\n}\n\n#[component]\nfn PrimitiveBubbleInput(\n    #[prop(optional, into)] name: MaybeProp<String>,\n    value: Signal<f64>,\n) -> impl IntoView {\n    let SliderContextValue {\n        values, ..\n    } = use_context().expect(\"SliderThumb must be used in a SliderRoot component\");\n\n    let node_ref = NodeRef::<Input>::new();\n    let prev_value = create_previous(Signal::derive(move || value.get()));\n\n    Effect::new(move |_| {\n        (|| {\n            let input = node_ref.get()?;\n            let input_el = window().get(\"HTMLInputElement\")?;\n            let input_proto = Reflect::get(&input_el, &JsString::from(\"prototype\"))\n                .ok()?\n                .dyn_into::<Object>()\n                .ok()?;\n\n            let input_descriptor_set = Reflect::get(\n                &Object::get_own_property_descriptor(&input_proto, &JsString::from(\"value\")),\n                &JsString::from(\"set\"),\n            )\n            .ok()?\n            .dyn_into::<Function>()\n            .ok()?;\n\n            if prev_value.get() != value.get() {\n                let ev_options = EventInit::new();\n                ev_options.set_bubbles(true);\n\n                let ev = Event::new_with_event_init_dict(\"input\", &ev_options).ok()?;\n\n                _ = Reflect::apply(\n                    &input_descriptor_set,\n                    &input,\n                    &Array::from_iter([JsValue::from_f64(value.get())]),\n                );\n\n                _ = input.dispatch_event(&ev);\n            }\n\n            Some(())\n        })();\n    });\n\n    Effect::new(move |_| {\n        if let Some(node) = node_ref.get() {\n            node.set_default_value(&value.get().to_string());\n        }\n    });\n\n    view! {\n        <input\n            aria-hidden\n            name=Signal::derive(move || {\n                    name.get()\n                        .map(|name| {\n                            format!(\"{}{}\", name, if values.get().len() > 1 { \"[]\" } else { \"\" })\n                        })\n                })\n                .into_attribute()\n            value=value.into_attribute()\n            node_ref=node_ref\n            style:display=\"none\"\n        />\n    }\n}\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                     ✨ FUNCTIONS ✨                        */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\nfn get_label(index: usize, total_values: usize) -> Option<String> {\n    match total_values {\n        n if n > 2 => Some(format!(\"Value {} of {}\", index + 1, total_values)),\n        2 => [\"Minimum\", \"Maximum\"]\n            .get(index)\n            .map(|label| label.to_string()),\n        _ => None,\n    }\n}\n\nfn convert_value_to_percentage(value: f64, min: f64, max: f64) -> f64 {\n    let max_steps = max - min;\n    let percent_per_step = 100. / max_steps;\n    let percentage = percent_per_step * (value - min);\n\n    percentage.clamp(0., 100.)\n}\n\nfn get_next_sorted_values(prev_values: &[f64], next_value: f64, at_index: usize) -> Vec<f64> {\n    let mut next_values = prev_values.to_vec();\n    if let Some(next_values) = next_values.get_mut(at_index) {\n        *next_values = next_value;\n    };\n\n    next_values.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));\n    next_values\n}\n\nfn find_closest_index(values: &[f64], next_value: f64) -> Option<usize> {\n    values\n        .iter()\n        .enumerate()\n        .min_by_key(|(_, &value)| (next_value - value).abs() as i32)\n        .map(|(index, _)| index)\n}\n\nfn has_min_steps_between_values(values: &[f64], min_steps_between_values: f64) -> bool {\n    if min_steps_between_values <= 0. {\n        return true;\n    }\n\n    values\n        .windows(2)\n        .map(|pair| pair[1] - pair[0])\n        .fold(None, |min: Option<f64>, current| match min {\n            Some(min_val) => Some(min_val.min(current)),\n            None => Some(current),\n        })\n        .map(|steps_between_values| steps_between_values >= min_steps_between_values)\n        .unwrap_or(false)\n}\n\nfn get_decimal_count(value: f64) -> usize {\n    value.to_string().split('.').nth(1).unwrap_or(\"\").len()\n}\n\nfn round_value(value: f64, decimal_count: u32) -> f64 {\n    let rounder = 10_f64.powi(decimal_count as i32);\n    (value * rounder).round() / rounder\n}\n\nfn get_thumb_in_bounds_offset(width: f64, left: f64, direction: f64) -> f64 {\n    let half_width = width / 2.0;\n    let half_percent = 50.0;\n    let offset = linear_scale((0.0, half_percent), (0.0, half_width));\n\n    (half_width - offset(left) * direction) * direction\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
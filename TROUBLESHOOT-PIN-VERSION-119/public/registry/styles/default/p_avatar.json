{
  "name": "p_avatar",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_avatar.rs",
      "content": "use html::AnyElement;\nuse leptos::*;\nuse leptos_use::{use_timeout_fn, UseTimeoutFnReturn};\nuse wasm_bindgen::{closure::Closure, JsCast};\n\nuse crate::registry::primitives::{p_primitive::Primitive, Attributes};\n\n#[derive(Clone)]\npub struct AvatarContextValue {\n    image_loading_status: Signal<ImageLoadingStatus>,\n    on_image_loading_status_change: Callback<ImageLoadingStatus>,\n}\n\n#[component]\npub fn PrimitiveAvatarRoot(\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let (image_loading_status, set_image_loading_status) = create_signal(ImageLoadingStatus::Idle);\n\n    provide_context(AvatarContextValue {\n        image_loading_status: Signal::derive(move || image_loading_status.get()),\n        on_image_loading_status_change: Callback::new(move |status| {\n            set_image_loading_status.set(status);\n        }),\n    });\n\n    view! {\n        <Primitive element=html::span node_ref=node_ref attrs=attrs as_child=as_child>\n            {children()}\n        </Primitive>\n    }\n}\n\n#[component]\npub fn PrimitiveAvatarImage(\n    #[prop(default=(|_|{}).into(), into)] on_loading_status_change: Callback<ImageLoadingStatus>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    #[prop(optional)] children: Option<ChildrenFn>,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<AvatarContextValue>()\n        .expect(\"AvatarImage needs to be in an AvatarRoot component\");\n\n    let src = attrs.iter().find(|item| item.0 == \"src\").and_then(|item| {\n        item.1\n            .as_nameless_value_string()\n            .map(|value| Signal::derive(move || value.to_string()))\n    });\n\n    let image_loading_status = use_image_loading_status(src);\n\n    let handle_loading_status_change = move |status: ImageLoadingStatus| {\n        leptos::Callable::call(&on_loading_status_change, status.clone());\n        leptos::Callable::call(&context.on_image_loading_status_change, status);\n    };\n\n    Effect::new(move |_| {\n        if image_loading_status.get() != ImageLoadingStatus::Idle {\n            handle_loading_status_change(image_loading_status.get());\n        }\n    });\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <Show when=move || image_loading_status.get() == ImageLoadingStatus::Loaded>\n            <Primitive element=html::img node_ref=node_ref attrs=attrs.clone() as_child=as_child>\n                {children.with_value(|children| children.as_ref().map(|children| children()))}\n            </Primitive>\n        </Show>\n    }\n}\n\n#[component]\npub fn PrimitiveAvatarFallback(\n    #[prop(optional, into)] delay_ms: MaybeSignal<f64>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<AvatarContextValue>()\n        .expect(\"AvatarFallback needs to be in an AvatarRoot component\");\n    let (can_render, set_can_render) = create_signal(false);\n\n    Effect::new(move |_| {\n        let UseTimeoutFnReturn {\n            start, ..\n        } = use_timeout_fn(\n            move |_: ()| {\n                set_can_render.set(true);\n            },\n            delay_ms.get(),\n        );\n\n        start(());\n    });\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <Show when=move || {\n            can_render.get() && context.image_loading_status.get() != ImageLoadingStatus::Loaded\n        }>\n            <Primitive element=html::span node_ref=node_ref as_child=as_child attrs=attrs.clone()>\n                {children.with_value(|children| children())}\n            </Primitive>\n        </Show>\n    }\n}\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                     ✨ FUNCTIONS ✨                        */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n#[derive(Clone, PartialEq, strum::Display)]\npub enum ImageLoadingStatus {\n    Idle,\n    Loaded,\n    Loading,\n    Error,\n}\n\nfn use_image_loading_status(src: Option<Signal<String>>) -> Signal<ImageLoadingStatus> {\n    let (loading_status, set_loading_status) = create_signal(ImageLoadingStatus::Idle);\n\n    Effect::new(move |_| {\n        let Some(src) = src else {\n            set_loading_status.set(ImageLoadingStatus::Error);\n            return;\n        };\n\n        let is_mounted = StoredValue::new(true);\n        let Ok(image) = document().create_element(\"img\") else {\n            set_loading_status.set(ImageLoadingStatus::Error);\n            return;\n        };\n\n        let loaded_status_callback = Closure::<dyn FnMut(_)>::new(move |_: web_sys::Event| {\n            if !is_mounted.get_value() {\n                return;\n            }\n\n            set_loading_status.set(ImageLoadingStatus::Loaded);\n        });\n        let error_status_callback = Closure::<dyn FnMut(_)>::new(move |_: web_sys::Event| {\n            if !is_mounted.get_value() {\n                return;\n            }\n\n            set_loading_status.set(ImageLoadingStatus::Error);\n        });\n\n        image\n            .add_event_listener_with_callback(\n                \"load\",\n                loaded_status_callback.as_ref().unchecked_ref(),\n            )\n            .expect(\"could not add load event callback\");\n\n        image\n            .add_event_listener_with_callback(\n                \"error\",\n                error_status_callback.as_ref().unchecked_ref(),\n            )\n            .expect(\"could not add load event callback\");\n\n        image\n            .set_attribute(\"src\", &src.get())\n            .expect(\"could not assign src attribute\");\n\n        loaded_status_callback.forget();\n        error_status_callback.forget();\n\n        on_cleanup(move || {\n            is_mounted.set_value(false);\n        });\n    });\n\n    loading_status.into()\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
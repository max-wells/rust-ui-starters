{
  "name": "p_scroll_area",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_scroll_area.rs",
      "content": "use leptos::{\n    ev::{pointerdown, pointerenter, pointerleave, pointermove, pointerup, scroll, wheel},\n    html::{AnyElement, Div},\n    leptos_dom::helpers::TimeoutHandle,\n    *,\n};\nuse leptos_use::{\n    use_debounce_fn, use_document, use_event_listener, use_event_listener_with_options, use_raf_fn,\n    use_resize_observer, utils::Pausable, UseEventListenerOptions,\n};\nuse std::time::Duration;\nuse wasm_bindgen::JsCast;\nuse web_sys::{CssStyleDeclaration, DomRect, PointerEvent, WheelEvent};\n\nuse crate::registry::primitives::{\n    linear_scale,\n    p_presence::create_presence,\n    p_primitive::Primitive,\n    p_utils_create_state_machine::{create_state_machine, InvalidState, MachineState},\n    Attributes, Direction, Orientation,\n};\n\n#[derive(Clone, Default)]\nstruct Scrollbar {\n    size: f64,\n    padding_start: f64,\n    padding_end: f64,\n}\n\n#[derive(Clone, Default)]\nstruct Sizes {\n    content: f64,\n    viewport: f64,\n    scrollbar: Scrollbar,\n}\n\n#[derive(Default, Clone, PartialEq)]\npub enum ScrollAreaKind {\n    Auto,\n    Always,\n    Scroll,\n    #[default]\n    Hover,\n}\n\n#[derive(Clone)]\npub struct ScrollAreaContextValue {\n    kind: MaybeSignal<ScrollAreaKind>,\n    direction: Signal<Direction>,\n    scroll_hide_delay: Signal<u64>,\n    scroll_area: NodeRef<AnyElement>,\n    viewport: NodeRef<AnyElement>,\n    // on_viewport_change: Callback<NodeRef<AnyElement>>,\n    content: NodeRef<Div>,\n    // on_content_change: Callback<NodeRef<AnyElement>>,\n    scrollbar_x: NodeRef<AnyElement>,\n    // on_scrollbar_x_change: Callback<Option<NodeRef<AnyElement>>>,\n    scrollbar_x_enabled: Signal<bool>,\n    on_scrollbar_x_enabled_change: Callback<bool>,\n    scrollbar_y: NodeRef<AnyElement>,\n    // on_scrollbar_y_change: Callback<Option<NodeRef<AnyElement>>>,\n    scrollbar_y_enabled: Signal<bool>,\n    on_scrollbar_y_enabled_change: Callback<bool>,\n    on_corner_width_change: Callback<u32>,\n    on_corner_height_change: Callback<u32>,\n}\n\n#[component]\npub fn PrimitiveScrollAreaRoot(\n    #[prop(optional, into)] kind: MaybeSignal<ScrollAreaKind>,\n    #[prop(optional, into)] direction: MaybeSignal<Direction>,\n    #[prop(default=600.into(), into)] scroll_hide_delay: MaybeSignal<u64>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let viewport = NodeRef::<AnyElement>::new();\n    let content = NodeRef::<Div>::new();\n    let scrollbar_x = NodeRef::<AnyElement>::new();\n    let scrollbar_y = NodeRef::<AnyElement>::new();\n\n    let (corner_width, set_corner_width) = create_signal(0);\n    let (corner_height, set_corner_height) = create_signal(0);\n\n    let (scrollbar_x_enabled, set_scrollbar_x_enabled) = create_signal(false);\n    let (scrollbar_y_enabled, set_scrollbar_y_enabled) = create_signal(false);\n\n    let direction = Signal::derive(move || direction.get());\n\n    provide_context(ScrollAreaContextValue {\n        kind,\n        direction,\n        scroll_hide_delay: Signal::derive(move || scroll_hide_delay.get()),\n        scroll_area: node_ref,\n        viewport,\n        content,\n        scrollbar_x,\n        scrollbar_x_enabled: Signal::derive(move || scrollbar_x_enabled.get()),\n        scrollbar_y,\n        scrollbar_y_enabled: Signal::derive(move || scrollbar_y_enabled.get()),\n        on_corner_width_change: Callback::new(move |value| {\n            set_corner_width.set(value);\n        }),\n        on_corner_height_change: Callback::new(move |value| {\n            set_corner_height.set(value);\n        }),\n        on_scrollbar_x_enabled_change: Callback::new(move |value| {\n            set_scrollbar_x_enabled.set(value);\n        }),\n        on_scrollbar_y_enabled_change: Callback::new(move |value| {\n            set_scrollbar_y_enabled.set(value);\n        }),\n    });\n\n    Effect::new(move |_| {\n        let Some(node) = node_ref.get() else {\n            return;\n        };\n\n        _ = node\n            .style(\"position\", \"relative\")\n            .style(\"--primitive-scroll-area-corner-width\", move || {\n                format!(\"{}px\", corner_width.get())\n            })\n            .style(\"--primitive-scroll-area-corner-height\", move || {\n                format!(\"{}px\", corner_height.get())\n            });\n    });\n\n    view! {\n        <Primitive\n            {..attrs}\n            attr:dir=move || direction.get().to_string()\n            element=html::div\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </Primitive>\n    }\n}\n\n#[component]\npub fn PrimitiveScrollAreaViewport(\n    #[prop(optional, into)] nonce: MaybeProp<String>,\n\n    //#[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<ScrollAreaContextValue>()\n        .expect(\"ScrollAreaViewport must be used in a ScrollAreaRoot component\");\n\n    let content_ref = context.content;\n\n    // Effect::new(move |_| {\n    //   let Some(node) = node_ref.get() else {\n    //     return;\n    //   };\n\n    //   (context.on_viewport_change)(node);\n    // });\n\n    // Effect::new(move |_| {\n    //   let Some(content) = context.content.get() else {\n    //     return;\n    //   };\n\n    //   (context.on_content_change)(content);\n    // });\n\n    Effect::new(move |_| {\n        let Some(viewport) = context.viewport.get() else {\n            return;\n        };\n\n        _ = viewport\n            .style(\n                \"overflow-x\",\n                if context.scrollbar_x_enabled.get() {\n                    \"scroll\"\n                } else {\n                    \"hidden\"\n                },\n            )\n            .style(\n                \"overflow-y\",\n                if context.scrollbar_y_enabled.get() {\n                    \"scroll\"\n                } else {\n                    \"hidden\"\n                },\n            );\n    });\n\n    view! {\n        <>\n            <style nonce=nonce\n                .into_attribute()>\n                r\"[data-leptix-scroll-area-viewport] {\n                  scrollbar-width:none;\n                  -ms-overflow-style:none;\n                  -webkit-overflow-scrolling:touch;\n                }\n                \n                [data-leptix-scroll-area-viewport]::-webkit-scrollbar{\n                  display:none\n                }\"\n            </style>\n\n            <Primitive\n                {..attrs}\n                attr:data-leptix-scroll-area-viewport=\"\"\n                element=html::div\n                node_ref=context.viewport\n                as_child=as_child\n            >\n                <div node_ref=content_ref style=\"min-width: 100%; display: table\">\n                    {children()}\n                </div>\n            </Primitive>\n        </>\n    }\n}\n\n#[component]\npub fn PrimitiveScrollAreaScrollbar(\n    #[prop(optional, into)] force_mount: MaybeSignal<bool>,\n    #[prop(optional, into)] orientation: MaybeSignal<Orientation>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<ScrollAreaContextValue>()\n        .expect(\"ScrollAreaScrollbar must be used in a ScrollAreaRoot component\");\n\n    let ScrollAreaContextValue {\n        on_scrollbar_x_enabled_change,\n        on_scrollbar_y_enabled_change,\n        ..\n    } = context;\n\n    Effect::new(move |_| {\n        if orientation.get() == Orientation::Horizontal {\n            leptos::Callable::call(&on_scrollbar_x_enabled_change, true);\n        } else {\n            leptos::Callable::call(&on_scrollbar_y_enabled_change, true);\n        }\n    });\n\n    on_cleanup(move || {\n        if orientation.get() == Orientation::Horizontal {\n            leptos::Callable::call(&on_scrollbar_x_enabled_change, false);\n        } else {\n            leptos::Callable::call(&on_scrollbar_y_enabled_change, false);\n        }\n    });\n\n    match context.kind.get() {\n        ScrollAreaKind::Hover => {\n            view! {\n                <PrimitiveScrollAreaScrollbarHover\n                    force_mount=force_mount\n                    orientation=orientation\n                    node_ref=node_ref\n                    attrs=attrs\n                    as_child=as_child\n                >\n                    {children()}\n                </PrimitiveScrollAreaScrollbarHover>\n            }\n        }\n        ScrollAreaKind::Scroll => {\n            view! {\n                <PrimitiveScrollAreaScrollbarScroll\n                    force_mount=force_mount\n                    orientation=orientation\n                    node_ref=node_ref\n                    attrs=attrs\n                    as_child=as_child\n                >\n                    {children()}\n                </PrimitiveScrollAreaScrollbarScroll>\n            }\n        }\n        ScrollAreaKind::Auto => {\n            view! {\n                <PrimitiveScrollAreaScrollbarAuto\n                    force_mount=force_mount\n                    orientation=orientation\n                    node_ref=node_ref\n                    attrs=attrs\n                    as_child=as_child\n                >\n                    {children()}\n                </PrimitiveScrollAreaScrollbarAuto>\n            }\n        }\n        ScrollAreaKind::Always => {\n            view! {\n                <PrimitiveScrollAreaScrollbarVisible\n                    orientation=orientation\n                    node_ref=node_ref\n                    attrs=attrs\n                    as_child=as_child\n                >\n                    {children()}\n                </PrimitiveScrollAreaScrollbarVisible>\n            }\n        }\n    }\n}\n\n#[component]\nfn PrimitiveScrollAreaScrollbarHover(\n    force_mount: MaybeSignal<bool>,\n    orientation: MaybeSignal<Orientation>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<ScrollAreaContextValue>()\n        .expect(\"ScrollAreaScrollbarHover must be used in a ScrollAreaRoot component\");\n\n    let (visible, set_visible) = create_signal(false);\n\n    Effect::new(move |_| {\n        let timer_handle_value = StoredValue::<Option<TimeoutHandle>>::new(None);\n\n        let remove_pointer_enter =\n            use_event_listener(context.scroll_area, pointerenter, move |_| {\n                if let Some(timeout_handle) = timer_handle_value.get_value() {\n                    timeout_handle.clear();\n                    timer_handle_value.set_value(None);\n                }\n\n                set_visible.set(true);\n            });\n\n        let remove_pointer_leave =\n            use_event_listener(context.scroll_area, pointerleave, move |_| {\n                let Ok(timer_handle) = set_timeout_with_handle(\n                    move || {\n                        set_visible.set(false);\n                    },\n                    Duration::from_millis(context.scroll_hide_delay.get()),\n                ) else {\n                    return;\n                };\n\n                timer_handle_value.set_value(Some(timer_handle));\n            });\n\n        on_cleanup(move || {\n            if let Some(timeout_handle) = timer_handle_value.get_value() {\n                timeout_handle.clear();\n                timer_handle_value.set_value(None);\n            }\n\n            remove_pointer_enter();\n            remove_pointer_leave();\n        });\n    });\n\n    let is_present = Signal::derive(move || force_mount.get() || visible.get());\n\n    let presence = create_presence(is_present, node_ref);\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <Show when=move || presence.get()>\n            <PrimitiveScrollAreaScrollbarAuto\n                {..attrs.clone()}\n                attr:data-state=move || if visible.get() { \"visible\" } else { \"hidden\" }\n                force_mount=force_mount\n                orientation=orientation\n                node_ref=node_ref\n                as_child=as_child\n            >\n                {children.with_value(|children| children())}\n            </PrimitiveScrollAreaScrollbarAuto>\n        </Show>\n    }\n}\n\n#[component]\nfn PrimitiveScrollAreaScrollbarScroll(\n    force_mount: MaybeSignal<bool>,\n    orientation: MaybeSignal<Orientation>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<ScrollAreaContextValue>()\n        .expect(\"ScrollAreaScrollbarAuto must be used in a ScrollAreaRoot component\");\n\n    let is_horizontal = Signal::derive(move || orientation.get() == Orientation::Horizontal);\n\n    let (state, send) = create_state_machine::<\n        ScrollAreaScrollbarScrollState,\n        ScrollAreaScrollbarScrollEvent,\n    >(ScrollAreaScrollbarScrollState::Hidden.into());\n\n    let scroll_end = use_debounce_fn(\n        move || leptos::Callable::call(&send, ScrollAreaScrollbarScrollEvent::ScrollEnd),\n        100.,\n    );\n\n    Effect::new(move |_| {\n        if state.get() != ScrollAreaScrollbarScrollState::Idle {\n            return;\n        }\n\n        let Ok(handle) = set_timeout_with_handle(\n            move || {\n                leptos::Callable::call(&send, ScrollAreaScrollbarScrollEvent::Hide);\n            },\n            Duration::from_millis(context.scroll_hide_delay.get()),\n        ) else {\n            return;\n        };\n\n        on_cleanup(move || {\n            handle.clear();\n        });\n    });\n\n    Effect::new(move |_| {\n        let Some(viewport) = context.viewport.get() else {\n            return;\n        };\n\n        let prev_scroll_position = StoredValue::new(if is_horizontal.get() {\n            viewport.scroll_left()\n        } else {\n            viewport.scroll_top()\n        });\n\n        let viewport_scroll_end = scroll_end.clone();\n        _ = use_event_listener(context.viewport, scroll, move |_| {\n            let scroll_position = if is_horizontal.get() {\n                viewport.scroll_left()\n            } else {\n                viewport.scroll_top()\n            };\n\n            let has_scroll_in_direction_changed =\n                prev_scroll_position.get_value() != scroll_position;\n\n            if has_scroll_in_direction_changed {\n                leptos::Callable::call(&send, ScrollAreaScrollbarScrollEvent::Scroll);\n                viewport_scroll_end();\n            }\n        });\n    });\n\n    let is_present = Signal::derive(move || {\n        force_mount.get() || state.get() == ScrollAreaScrollbarScrollState::Hidden\n    });\n\n    let presence = create_presence(is_present, node_ref);\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <Show when=move || presence.get()>\n            <PrimitiveScrollAreaScrollbarVisible\n                {..attrs.clone()}\n                attr:data-state=move || {\n                    if state.get() == ScrollAreaScrollbarScrollState::Hidden {\n                        \"hidden\"\n                    } else {\n                        \"visible\"\n                    }\n                }\n                orientation=orientation\n                on_pointer_enter=Callback::new(move |_| {\n                    leptos::Callable::call(&send, ScrollAreaScrollbarScrollEvent::PointerEnter)\n                })\n                on_pointer_leave=Callback::new(move |_| {\n                    leptos::Callable::call(&send, ScrollAreaScrollbarScrollEvent::PointerLeave)\n                })\n                node_ref=node_ref\n                as_child=as_child\n            >\n                {children.with_value(|children| children())}\n            </PrimitiveScrollAreaScrollbarVisible>\n        </Show>\n    }\n}\n\n#[component]\nfn PrimitiveScrollAreaScrollbarAuto(\n    force_mount: MaybeSignal<bool>,\n    orientation: MaybeSignal<Orientation>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<ScrollAreaContextValue>()\n        .expect(\"ScrollAreaScrollbarAuto must be used in a ScrollAreaRoot component\");\n\n    let (visible, set_visible) = create_signal(false);\n\n    let is_horizontal = move || orientation.get() == Orientation::Horizontal;\n\n    let handle_resize = use_debounce_fn(\n        move || {\n            let Some(viewport) = context.viewport.get() else {\n                return;\n            };\n\n            set_visible.set(if is_horizontal() {\n                viewport.offset_width() < viewport.scroll_width()\n            } else {\n                viewport.offset_height() < viewport.scroll_height()\n            });\n        },\n        10.,\n    );\n\n    let viewport_resize = handle_resize.clone();\n    use_resize_observer(context.viewport, move |_, _| {\n        viewport_resize();\n    });\n\n    let content_resize = handle_resize.clone();\n    use_resize_observer(context.content, move |_, _| {\n        content_resize();\n    });\n\n    let is_present = Signal::derive(move || force_mount.get() || visible.get());\n\n    let presence = create_presence(is_present, node_ref);\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <Show when=move || presence.get()>\n            <PrimitiveScrollAreaScrollbarVisible\n                {..attrs.clone()}\n                attr:data-state=move || if visible.get() { \"visible\" } else { \"hidden\" }\n                orientation=orientation\n                node_ref=node_ref\n                as_child=as_child\n            >\n                {children.with_value(|children| children())}\n            </PrimitiveScrollAreaScrollbarVisible>\n        </Show>\n    }\n}\n\n#[component]\nfn PrimitiveScrollAreaScrollbarVisible(\n    orientation: MaybeSignal<Orientation>,\n\n    #[prop(default=(|_|{}).into(), into)] on_pointer_enter: Callback<()>,\n    #[prop(default=(|_|{}).into(), into)] on_pointer_leave: Callback<()>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<ScrollAreaContextValue>()\n        .expect(\"ScrollAreaScrollbarVisible must be used in a ScrollAreaRoot component\");\n\n    let thumb_ref = RwSignal::<Option<HtmlElement<AnyElement>>>::new(None);\n\n    let pointer_offset = StoredValue::new(0.0f64);\n    let (sizes, set_sizes) = create_signal(Sizes::default());\n    let thumb_ratio = Signal::derive(move || sizes.get().viewport / sizes.get().content);\n\n    let get_scroll_position = move |pointer_position: f64, direction: Direction| {\n        get_scroll_position_from_pointer(\n            pointer_position,\n            pointer_offset.get_value(),\n            &sizes.get(),\n            direction,\n        )\n    };\n\n    view! {\n        {move || {\n            let merged_attrs = attrs.clone();\n            let children = children.clone();\n            match orientation.get() {\n                Orientation::Horizontal => {\n                    view! {\n                        <PrimitiveScrollAreaScrollbarX\n                            on_sizes_change=Callback::new(move |sizes| {\n                                set_sizes.set(sizes);\n                            })\n                            on_pointer_enter=on_pointer_enter\n                            on_pointer_leave=on_pointer_leave\n                            sizes=Signal::derive(move || sizes.get()).into()\n                            has_thumb=Signal::derive(move || {\n                                    thumb_ratio.get() > 0. && thumb_ratio.get() < 1.\n                                })\n                                .into()\n                            on_thumb_change=Callback::new(move |thumb| {\n                                thumb_ref.set(Some(thumb));\n                            })\n                            on_thumb_pointer_up=Callback::new(move |_| {\n                                pointer_offset.set_value(0.)\n                            })\n                            on_thumb_pointer_down=Callback::new(move |pointer_position: f64| {\n                                pointer_offset.set_value(pointer_position);\n                            })\n                            on_thumb_position_change=Callback::new(move |_| {\n                                let (Some(viewport), Some(thumb_el)) = (\n                                    context.viewport.get(),\n                                    thumb_ref.get(),\n                                ) else {\n                                    return;\n                                };\n                                let scroll_position = viewport.scroll_left() as f64;\n                                let offset = get_thumb_offset_from_scroll(\n                                    scroll_position,\n                                    &sizes.get(),\n                                    context.direction.get(),\n                                );\n                                _ = thumb_el\n                                    .style(\"transform\", format!(\"translate3d({offset}px, 0, 0)\"));\n                            })\n                            on_wheel_scroll=Callback::new(move |scroll_position: f64| {\n                                if let Some(viewport) = context.viewport.get() {\n                                    viewport.set_scroll_top(scroll_position as i32);\n                                }\n                            })\n                            on_drag_scroll=Callback::new(move |pointer_position: f64| {\n                                if let Some(viewport) = context.viewport.get() {\n                                    viewport\n                                        .set_scroll_top(\n                                            get_scroll_position(\n                                                pointer_position,\n                                                context.direction.get(),\n                                            ) as i32,\n                                        );\n                                }\n                            })\n                            node_ref=node_ref\n                            attrs=merged_attrs\n                            as_child=as_child\n                        >\n                            {children()}\n                        </PrimitiveScrollAreaScrollbarX>\n                    }\n                }\n                Orientation::Vertical => {\n                    view! {\n                        <PrimitiveScrollAreaScrollbarY\n                            on_sizes_change=Callback::new(move |sizes| {\n                                set_sizes.set(sizes);\n                            })\n                            on_pointer_enter=on_pointer_enter\n                            on_pointer_leave=on_pointer_leave\n                            sizes=Signal::derive(move || sizes.get()).into()\n                            has_thumb=Signal::derive(move || {\n                                    thumb_ratio.get() > 0. && thumb_ratio.get() < 1.\n                                })\n                                .into()\n                            on_thumb_change=Callback::new(move |thumb| {\n                                thumb_ref.set(Some(thumb));\n                            })\n                            on_thumb_pointer_up=Callback::new(move |_| {\n                                pointer_offset.set_value(0.)\n                            })\n                            on_thumb_pointer_down=Callback::new(move |pointer_position| {\n                                pointer_offset.set_value(pointer_position);\n                            })\n                            on_thumb_position_change=Callback::new(move |_| {\n                                let (Some(viewport), Some(thumb_el)) = (\n                                    context.viewport.get(),\n                                    thumb_ref.get(),\n                                ) else {\n                                    return;\n                                };\n                                let scroll_position = viewport.scroll_top() as f64;\n                                let offset = get_thumb_offset_from_scroll(\n                                    scroll_position,\n                                    &sizes.get(),\n                                    context.direction.get(),\n                                );\n                                _ = thumb_el\n                                    .style(\"transform\", format!(\"translate3d(0, {offset}px, 0)\"));\n                            })\n                            on_wheel_scroll=Callback::new(move |scroll_position: f64| {\n                                if let Some(viewport) = context.viewport.get() {\n                                    viewport.set_scroll_top(scroll_position as i32);\n                                }\n                            })\n                            on_drag_scroll=Callback::new(move |pointer_position| {\n                                if let Some(viewport) = context.viewport.get() {\n                                    viewport\n                                        .set_scroll_top(\n                                            get_scroll_position(\n                                                pointer_position,\n                                                context.direction.get(),\n                                            ) as i32,\n                                        );\n                                }\n                            })\n                            node_ref=node_ref\n                            attrs=merged_attrs\n                            as_child=as_child\n                        >\n                            {children()}\n                        </PrimitiveScrollAreaScrollbarY>\n                    }\n                }\n            }\n        }}\n    }\n}\n\n#[component]\nfn PrimitiveScrollAreaScrollbarX(\n    sizes: MaybeSignal<Sizes>,\n    has_thumb: MaybeSignal<bool>,\n\n    on_sizes_change: Callback<Sizes>,\n    on_thumb_change: Callback<HtmlElement<AnyElement>>,\n    on_thumb_pointer_up: Callback<()>,\n    on_thumb_pointer_down: Callback<f64>,\n    on_thumb_position_change: Callback<()>,\n    on_wheel_scroll: Callback<f64>,\n    on_drag_scroll: Callback<f64>,\n    #[prop(default=Callback::new(|_:()|{}))] on_pointer_enter: Callback<()>,\n    #[prop(default=Callback::new(|_:()|{}))] on_pointer_leave: Callback<()>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<ScrollAreaContextValue>()\n        .expect(\"ScrollAreaScrollbarX must be used in a ScrollAreaRoot component\");\n\n    let (computed_style, set_computed_style) = create_signal::<Option<CssStyleDeclaration>>(None);\n\n    let effect_sizes = sizes.clone();\n    Effect::new(move |_| {\n        let Some(node) = node_ref.get() else {\n            return;\n        };\n\n        if let Ok(computed_style) = window().get_computed_style(&node) {\n            set_computed_style.set(computed_style);\n        }\n\n        _ = node\n            .style(\n                \"right\",\n                if context.direction.get() == Direction::LeftToRight {\n                    \"var(--primitive-scroll-area-corner-width)\"\n                } else {\n                    \"0\"\n                },\n            )\n            .style(\n                \"left\",\n                if context.direction.get() == Direction::RightToLeft {\n                    \"var(--primitive-scroll-area-corner-width)\"\n                } else {\n                    \"0\"\n                },\n            )\n            .style(\"bottom\", 0)\n            .style(\n                \"--primitive-scroll-area-thumb-width\",\n                format!(\"{}px\", get_thumb_size(&effect_sizes.get()).trunc()),\n            );\n    });\n\n    view! {\n        <PrimitiveScrollAreaScrollbarImpl\n            {..attrs}\n            attr:data-orientation=\"horizontal\"\n            sizes=Signal::derive(move || sizes.get())\n            has_thumb=Signal::derive(move || has_thumb.get())\n            on_pointer_enter=on_pointer_enter\n            on_pointer_leave=on_pointer_leave\n            on_thumb_pointer_up=on_thumb_pointer_up\n            on_thumb_change=on_thumb_change\n            on_thumb_pointer_down=Callback::new(move |Pointer { x, .. }| {\n                leptos::Callable::call(&on_thumb_pointer_down, x);\n            })\n            on_thumb_position_change=on_thumb_position_change\n            on_drag_scroll=Callback::new(move |Pointer { y, .. }| {\n                leptos::Callable::call(&on_drag_scroll, y);\n            })\n            on_wheel_scroll=Callback::new(move |(event, max_scroll_pos): (WheelEvent, f64)| {\n                let Some(viewport) = context.viewport.get() else {\n                    return;\n                };\n                let scroll_pos = viewport.scroll_top() as f64 + event.delta_y();\n                leptos::Callable::call(&on_wheel_scroll, scroll_pos);\n                if is_scrolling_within_scrollbar_bounds(scroll_pos, max_scroll_pos) {\n                    event.prevent_default();\n                }\n            })\n            on_resize=Callback::new(move |_| {\n                let (Some(node_el), Some(viewport), Some(computed_style)) = (\n                    node_ref.get(),\n                    context.viewport.get(),\n                    computed_style.get(),\n                ) else {\n                    return;\n                };\n                leptos::Callable::call(\n                    &on_sizes_change,\n                    Sizes {\n                        content: viewport.scroll_height() as f64,\n                        viewport: viewport.offset_height() as f64,\n                        scrollbar: Scrollbar {\n                            size: node_el.client_height() as f64,\n                            padding_start: computed_style\n                                .get_property_value(\"padding-top\")\n                                .expect(\"no padding top\")\n                                .parse::<f64>()\n                                .unwrap(),\n                            padding_end: computed_style\n                                .get_property_value(\"padding-bottom\")\n                                .expect(\"no padding bottom\")\n                                .parse::<f64>()\n                                .unwrap(),\n                        },\n                    },\n                );\n            })\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </PrimitiveScrollAreaScrollbarImpl>\n    }\n}\n\n#[component]\nfn PrimitiveScrollAreaScrollbarY(\n    #[prop(default=(|_|{}).into(), into)] on_pointer_enter: Callback<()>,\n    #[prop(default=(|_|{}).into(), into)] on_pointer_leave: Callback<()>,\n\n    sizes: MaybeSignal<Sizes>,\n    has_thumb: MaybeSignal<bool>,\n    on_sizes_change: Callback<Sizes>,\n    on_thumb_change: Callback<HtmlElement<AnyElement>>,\n    on_thumb_pointer_up: Callback<()>,\n    on_thumb_pointer_down: Callback<f64>,\n    on_thumb_position_change: Callback<()>,\n    on_wheel_scroll: Callback<f64>,\n    on_drag_scroll: Callback<f64>,\n\n    #[prop(attrs)] attrs: Attributes,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<ScrollAreaContextValue>()\n        .expect(\"ScrollAreaScrollbarY must be used in a ScrollAreaRoot component\");\n\n    let (computed_style, set_computed_style) = create_signal::<Option<CssStyleDeclaration>>(None);\n\n    let effect_sizes = sizes.clone();\n    Effect::new(move |_| {\n        let Some(node) = node_ref.get() else {\n            return;\n        };\n\n        if let Ok(computed_style) = window().get_computed_style(&node) {\n            set_computed_style.set(computed_style);\n        }\n\n        _ = node\n            .style(\"top\", 0)\n            .style(\n                \"right\",\n                (context.direction.get() == Direction::LeftToRight).then_some(0),\n            )\n            .style(\n                \"left\",\n                (context.direction.get() == Direction::RightToLeft).then_some(0),\n            )\n            .style(\"bottom\", \"var(--primitive-scroll-area-corner-height)\")\n            .style(\n                \"--primitive-scroll-area-thumb-height\",\n                format!(\"{}px\", get_thumb_size(&effect_sizes.get()).trunc()),\n            );\n    });\n\n    view! {\n        <PrimitiveScrollAreaScrollbarImpl\n            {..attrs}\n            attr:data-orientation=\"vertical\"\n            sizes=Signal::derive(move || sizes.get())\n            has_thumb=Signal::derive(move || has_thumb.get())\n            on_pointer_enter=on_pointer_enter\n            on_pointer_leave=on_pointer_leave\n            on_thumb_pointer_up=on_thumb_pointer_up\n            on_thumb_change=on_thumb_change\n            on_thumb_pointer_down=Callback::new(move |Pointer { x, .. }| {\n                leptos::Callable::call(&on_thumb_pointer_down, x);\n            })\n            on_thumb_position_change=on_thumb_position_change\n            on_drag_scroll=Callback::new(move |Pointer { y, .. }| {\n                leptos::Callable::call(&on_drag_scroll, y);\n            })\n            on_wheel_scroll=Callback::new(move |(event, max_scroll_pos): (WheelEvent, f64)| {\n                let Some(viewport) = context.viewport.get() else {\n                    return;\n                };\n                let scroll_pos = viewport.scroll_top() as f64 + event.delta_y();\n                leptos::Callable::call(&on_wheel_scroll, scroll_pos);\n                if is_scrolling_within_scrollbar_bounds(scroll_pos, max_scroll_pos) {\n                    event.prevent_default();\n                }\n            })\n            on_resize=Callback::new(move |_| {\n                let (Some(node_el), Some(viewport), Some(computed_style)) = (\n                    node_ref.get(),\n                    context.viewport.get(),\n                    computed_style.get(),\n                ) else {\n                    return;\n                };\n                leptos::Callable::call(\n                    &on_sizes_change,\n                    Sizes {\n                        content: viewport.scroll_height() as f64,\n                        viewport: viewport.offset_height() as f64,\n                        scrollbar: Scrollbar {\n                            size: node_el.client_height() as f64,\n                            padding_start: computed_style\n                                .get_property_value(\"padding-top\")\n                                .expect(\"no padding top\")\n                                .parse::<f64>()\n                                .unwrap_or_default(),\n                            padding_end: computed_style\n                                .get_property_value(\"padding-bottom\")\n                                .expect(\"no padding bottom\")\n                                .parse::<f64>()\n                                .unwrap_or_default(),\n                        },\n                    },\n                );\n            })\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </PrimitiveScrollAreaScrollbarImpl>\n    }\n}\n\nfn is_scrolling_within_scrollbar_bounds(scroll_pos: f64, max_scroll_pos: f64) -> bool {\n    scroll_pos > 0. && scroll_pos < max_scroll_pos\n}\n\n#[derive(Clone)]\nstruct ScrollbarContextValue {\n    has_thumb: Signal<bool>,\n    scrollbar: NodeRef<AnyElement>,\n    on_thumb_change: Callback<HtmlElement<AnyElement>>,\n    on_thumb_pointer_up: Callback<()>,\n    on_thumb_pointer_down: Callback<Pointer>,\n    on_thumb_position_change: Callback<()>,\n}\n\nstruct Pointer {\n    x: f64,\n    y: f64,\n}\n\n#[component]\nfn PrimitiveScrollAreaScrollbarImpl(\n    sizes: Signal<Sizes>,\n    has_thumb: Signal<bool>,\n    #[prop(default=(|_|{}).into(), into)] on_pointer_enter: Callback<()>,\n    #[prop(default=(|_|{}).into(), into)] on_pointer_leave: Callback<()>,\n    on_thumb_change: Callback<HtmlElement<AnyElement>>,\n    on_thumb_pointer_up: Callback<()>,\n    on_thumb_pointer_down: Callback<Pointer>,\n    on_thumb_position_change: Callback<()>,\n    on_drag_scroll: Callback<Pointer>,\n    on_wheel_scroll: Callback<(WheelEvent, f64)>,\n    on_resize: Callback<()>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<ScrollAreaContextValue>()\n        .expect(\"ScrollAreaScrollbarImpl must be used in a ScrollArea component\");\n\n    let rect_ref = StoredValue::<Option<DomRect>>::new(None);\n    let previous_webkit_user_select_ref = StoredValue::new(String::new());\n    let max_scroll_position = move || sizes.get().content - sizes.get().viewport;\n\n    Effect::new(move |_| {\n        let document = use_document();\n        let Some(document) = document.as_ref() else {\n            return;\n        };\n\n        _ = use_event_listener_with_options(\n            document.clone(),\n            wheel,\n            move |ev: WheelEvent| {\n                let Some(target) = ev.target() else {\n                    return;\n                };\n\n                let Some(target_el) = target.dyn_ref::<web_sys::Element>() else {\n                    return;\n                };\n\n                let is_scroll_wheel = node_ref\n                    .get()\n                    .map(|scrollbar| scrollbar.contains(Some(target_el)))\n                    .unwrap_or(false);\n\n                if is_scroll_wheel {\n                    leptos::Callable::call(&on_wheel_scroll, (ev, max_scroll_position()));\n                }\n            },\n            UseEventListenerOptions::default().passive(false),\n        );\n    });\n\n    _ = watch(\n        move || {\n            _ = sizes.get();\n        },\n        move |_, _, _| {\n            leptos::Callable::call(&on_thumb_position_change, ());\n        },\n        true,\n    );\n\n    use_resize_observer(node_ref, move |_, _| {\n        leptos::Callable::call(&on_resize, ());\n    });\n\n    use_resize_observer(context.content, move |_, _| {\n        leptos::Callable::call(&on_resize, ());\n    });\n\n    let handle_drag_scroll = move |ev: PointerEvent| {\n        let Some(rect) = rect_ref.get_value() else {\n            return;\n        };\n\n        leptos::Callable::call(\n            &on_drag_scroll,\n            Pointer {\n                x: ev.client_x() as f64 - rect.left(),\n                y: ev.client_y() as f64 - rect.top(),\n            },\n        );\n    };\n\n    Effect::new(move |_| {\n        let Some(el) = node_ref.get() else {\n            return;\n        };\n\n        _ = el\n            .style(\"position\", \"absolute\")\n            .on(pointerdown, move |ev: PointerEvent| {\n                let main_pointer = 0;\n\n                if ev.button() != main_pointer {\n                    return;\n                }\n                let Some(target) = ev.target() else {\n                    return;\n                };\n\n                let Some(el) = target.dyn_ref::<web_sys::HtmlElement>() else {\n                    return;\n                };\n\n                rect_ref.set_value(Some(el.get_bounding_client_rect()));\n\n                let Some(body) = document().body() else {\n                    return;\n                };\n\n                // body.style.webkitUserSelect = \"none\";\n\n                let Ok(webkit_user_select) = body.style().get_property_value(\"webkitUserSelect\")\n                else {\n                    return;\n                };\n\n                previous_webkit_user_select_ref.set_value(webkit_user_select);\n\n                if let Some(viewport) = context.viewport.get() {\n                    _ = viewport.style(\"scroll-behavior\", \"auto\");\n                }\n\n                handle_drag_scroll(ev);\n            })\n            .on(pointermove, move |ev: PointerEvent| {\n                handle_drag_scroll(ev);\n            })\n            .on(pointerup, move |ev: PointerEvent| {\n                let Some(target) = ev.target() else {\n                    return;\n                };\n\n                let Some(el) = target.dyn_ref::<web_sys::HtmlElement>() else {\n                    return;\n                };\n\n                if el.has_pointer_capture(ev.pointer_id()) {\n                    _ = el.release_pointer_capture(ev.pointer_id());\n                }\n\n                let Some(body) = document().body() else {\n                    return;\n                };\n\n                // body.style.webkitUserSelect = previous_webkit_user_select_ref.get_value();\n\n                if let Some(viewport) = context.viewport.get() {\n                    _ = viewport.style(\"scroll-behavior\", \"\");\n                }\n\n                rect_ref.set_value(None);\n            })\n            .on(pointerenter, move |_| {\n                leptos::Callable::call(&on_pointer_enter, ());\n            })\n            .on(pointerleave, move |_| {\n                leptos::Callable::call(&on_pointer_leave, ());\n            });\n    });\n\n    provide_context(ScrollbarContextValue {\n        scrollbar: node_ref,\n        on_thumb_change,\n        has_thumb,\n        on_thumb_pointer_up,\n        on_thumb_pointer_down,\n        on_thumb_position_change,\n    });\n\n    view! {\n        <Primitive element=html::div node_ref=node_ref attrs=attrs as_child=as_child>\n            {children()}\n        </Primitive>\n    }\n}\n\n#[component]\npub fn PrimitiveScrollAreaThumb(\n    #[prop(optional)] force_mount: MaybeSignal<bool>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    #[prop(optional)] children: Option<ChildrenFn>,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let ScrollbarContextValue {\n        has_thumb, ..\n    } = use_context::<ScrollbarContextValue>()\n        .expect(\"ScrollAreaThumb must be used in a ScrollAreaScrollbarImpl component\");\n\n    let is_present = Signal::derive(move || has_thumb.get() || force_mount.get());\n\n    let presence = create_presence(is_present, node_ref);\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <Show when=move || presence.get()>\n            <PrimitiveScrollAreaThumbImpl node_ref=node_ref attrs=attrs.clone() as_child=as_child>\n                {children.with_value(|children| children.as_ref().map(|children| children()))}\n            </PrimitiveScrollAreaThumbImpl>\n        </Show>\n    }\n}\n\n#[component]\nfn PrimitiveScrollAreaThumbImpl(\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    #[prop(optional)] children: Option<ChildrenFn>,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<ScrollAreaContextValue>()\n        .expect(\"ScrollAreaThumb must be used in a ScrollArea component\");\n    let scrollbar_context = use_context::<ScrollbarContextValue>()\n        .expect(\"ScrollAreaThumb must be used in a ScrollAreaScrollbarImpl component\");\n\n    let remove_unlinked_scroll_listener_ref = StoredValue::<Option<Callback<()>>>::new(None);\n\n    let debounce_scroll_end = use_debounce_fn(\n        move || {\n            let Some(remove_unlinked_scroll_listener) =\n                remove_unlinked_scroll_listener_ref.get_value()\n            else {\n                return;\n            };\n\n            leptos::Callable::call(&remove_unlinked_scroll_listener, ());\n            remove_unlinked_scroll_listener_ref.set_value(None);\n        },\n        100.0,\n    );\n\n    Effect::new(move |_| {\n        let scroll_listener_debounce_end = debounce_scroll_end.clone();\n        _ = use_event_listener(context.viewport, scroll, move |_| {\n            scroll_listener_debounce_end();\n\n            if remove_unlinked_scroll_listener_ref.get_value().is_some() {\n                return;\n            }\n\n            let Some(viewport) = context.viewport.get() else {\n                return;\n            };\n\n            let listener =\n                add_unlinked_scroll_listener(viewport, scrollbar_context.on_thumb_position_change);\n            remove_unlinked_scroll_listener_ref.set_value(Some(listener));\n\n            leptos::Callable::call(&scrollbar_context.on_thumb_position_change, ());\n        });\n\n        leptos::Callable::call(&scrollbar_context.on_thumb_position_change, ());\n    });\n\n    Effect::new(move |_| {\n        let Some(node) = node_ref.get() else {\n            return;\n        };\n\n        let node = node\n            .style(\"width\", \"var(--primitive-scroll-area-thumb-width)\")\n            .style(\"height\", \"var(--primitive-scroll-area-thumb-height)\")\n            // onPointerDownCapture?\n            .on(pointerdown, move |ev: PointerEvent| {\n                let Some(target) = ev.target() else {\n                    return;\n                };\n\n                let Some(node) = target.dyn_ref::<web_sys::HtmlElement>() else {\n                    return;\n                };\n\n                let rect = node.get_bounding_client_rect();\n                let x = ev.client_x() as f64 - rect.left();\n                let y = ev.client_y() as f64 - rect.top();\n\n                leptos::Callable::call(\n                    &scrollbar_context.on_thumb_pointer_down,\n                    Pointer {\n                        x,\n                        y,\n                    },\n                );\n            })\n            .on(pointerup, move |_| {\n                leptos::Callable::call(&scrollbar_context.on_thumb_pointer_up, ());\n            });\n\n        leptos::Callable::call(&scrollbar_context.on_thumb_change, node);\n    });\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <Primitive element=html::div as_child=as_child node_ref=node_ref attrs=attrs>\n            {children.with_value(|children| children.as_ref().map(|children| children()))}\n        </Primitive>\n    }\n}\n\n#[component]\npub fn PrimitiveScrollAreaCorner(\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    #[prop(optional)] children: Option<ChildrenFn>,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let context = use_context::<ScrollAreaContextValue>()\n        .expect(\"ScrollAreaCorner must be used in a ScrollArea component\");\n\n    let has_both_scrollbars_visible =\n        move || context.scrollbar_x.get().is_some() && context.scrollbar_y.get().is_some();\n    let has_corner =\n        move || context.kind.get() != ScrollAreaKind::Scroll && has_both_scrollbars_visible();\n\n    let (width, set_width) = create_signal(0);\n    let (height, set_height) = create_signal(0);\n    let has_size = move || width.get() != 0 && height.get() != 0;\n\n    use_resize_observer(context.scrollbar_x, move |_, _| {\n        let height = match context.scrollbar_x.get() {\n            Some(scrollbar_x) => scrollbar_x.offset_height(),\n            None => 0,\n        };\n\n        leptos::Callable::call(&context.on_corner_height_change, height as u32);\n        set_height.set(height);\n    });\n\n    use_resize_observer(context.scrollbar_y, move |_, _| {\n        let width = match context.scrollbar_y.get() {\n            Some(scrollbar_y) => scrollbar_y.offset_width(),\n            None => 0,\n        };\n\n        leptos::Callable::call(&context.on_corner_width_change, width as u32);\n        set_width.set(width);\n    });\n\n    Effect::new(move |_| {\n        let Some(node) = node_ref.get() else {\n            return;\n        };\n\n        _ = node\n            .style(\"width\", width.get())\n            .style(\"height\", height.get())\n            .style(\"position\", \"absolute\")\n            .style(\n                \"right\",\n                (context.direction.get() == Direction::LeftToRight).then_some(0),\n            )\n            .style(\n                \"left\",\n                (context.direction.get() == Direction::RightToLeft).then_some(0),\n            )\n            .style(\"bottom\", 0);\n    });\n\n    let attrs = StoredValue::new(attrs);\n    let children = StoredValue::new(children);\n\n    view! {\n        <Show when=move || has_corner() || has_size()>\n            <Primitive\n                attrs=attrs.get_value()\n                element=html::div\n                node_ref=node_ref\n                as_child=as_child\n            >\n                {children.with_value(|children| children.as_ref().map(|children| children()))}\n            </Primitive>\n        </Show>\n    }\n}\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                     ✨ FUNCTIONS ✨                        */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\nfn get_thumb_size(sizes: &Sizes) -> f64 {\n    let ratio = sizes.viewport / sizes.content;\n    let scrollbar_padding = sizes.scrollbar.padding_start - sizes.scrollbar.padding_end;\n    let thumb_size = (sizes.scrollbar.size - scrollbar_padding) * ratio;\n\n    thumb_size.max(18.)\n}\n\nfn get_scroll_position_from_pointer(\n    pointer_position: f64,\n    pointer_offset: f64,\n    sizes: &Sizes,\n    direction: Direction,\n) -> f64 {\n    let thumb_size_px = get_thumb_size(sizes);\n    let offset = if pointer_offset == 0. {\n        thumb_size_px / 2.\n    } else {\n        pointer_offset\n    };\n    let thumb_offset_from_end = thumb_size_px - offset;\n    let min_pointer_pos = sizes.scrollbar.padding_start + offset;\n    let max_pointer_pos =\n        sizes.scrollbar.size - sizes.scrollbar.padding_end - thumb_offset_from_end;\n    let max_scroll_pos = sizes.content - sizes.viewport;\n    let scroll_range = if direction == Direction::LeftToRight {\n        (0., max_scroll_pos)\n    } else {\n        (max_scroll_pos * -1., 0.)\n    };\n    let interpolate = linear_scale((min_pointer_pos, max_pointer_pos), scroll_range);\n\n    interpolate(pointer_position)\n}\n\nfn get_thumb_offset_from_scroll(scroll_position: f64, sizes: &Sizes, direction: Direction) -> f64 {\n    let thumb_size_px = get_thumb_size(sizes);\n    let scrollbar_padding = sizes.scrollbar.padding_start + sizes.scrollbar.padding_end;\n    let scrollbar = sizes.scrollbar.size - scrollbar_padding;\n    let max_scroll_pos = sizes.content - sizes.viewport;\n    let max_thumb_pos = scrollbar - thumb_size_px;\n    let scroll_clamp_range = if direction == Direction::LeftToRight {\n        (0., max_scroll_pos)\n    } else {\n        (max_scroll_pos * -1., 0.)\n    };\n\n    let interpolate = linear_scale((0., max_scroll_pos), (0., max_thumb_pos));\n\n    interpolate((scroll_position).clamp(scroll_clamp_range.0, scroll_clamp_range.1))\n}\n\nfn add_unlinked_scroll_listener(\n    node: HtmlElement<AnyElement>,\n    handler: Callback<()>,\n) -> Callback<()> {\n    let previous_position = StoredValue::new((node.scroll_left(), node.scroll_top()));\n\n    let Pausable {\n        pause, ..\n    } = use_raf_fn(move |_| {\n        let position = (node.scroll_left(), node.scroll_top());\n\n        let is_horizontal_scroll = previous_position.get_value().0 != position.0;\n        let is_vertical_scroll = previous_position.get_value().1 != position.1;\n\n        if is_horizontal_scroll || is_vertical_scroll {\n            leptos::Callable::call(&handler, ());\n        }\n\n        previous_position.set_value(position);\n    });\n\n    Callback::new(move |_| {\n        pause();\n    })\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\nenum ScrollAreaScrollbarScrollState {\n    Hidden,\n    Scrolling,\n    Interacting,\n    Idle,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\nenum ScrollAreaScrollbarScrollEvent {\n    Scroll,\n    ScrollEnd,\n    PointerEnter,\n    PointerLeave,\n    Hide,\n}\n\nimpl MachineState<ScrollAreaScrollbarScrollState, ScrollAreaScrollbarScrollEvent>\n    for ScrollAreaScrollbarScrollState\n{\n    fn send(&self, event: ScrollAreaScrollbarScrollEvent) -> Result<Self, InvalidState> {\n        match (self, event) {\n            (Self::Hidden, ScrollAreaScrollbarScrollEvent::Scroll) => Ok(Self::Scrolling),\n            (Self::Scrolling, ScrollAreaScrollbarScrollEvent::ScrollEnd) => Ok(Self::Idle),\n            (Self::Scrolling, ScrollAreaScrollbarScrollEvent::PointerEnter) => {\n                Ok(Self::Interacting)\n            }\n            (Self::Interacting, ScrollAreaScrollbarScrollEvent::Scroll) => Ok(Self::Interacting),\n            (Self::Interacting, ScrollAreaScrollbarScrollEvent::PointerLeave) => Ok(Self::Idle),\n            (Self::Idle, ScrollAreaScrollbarScrollEvent::Hide) => Ok(Self::Hidden),\n            (Self::Idle, ScrollAreaScrollbarScrollEvent::Scroll) => Ok(Self::Scrolling),\n            (Self::Idle, ScrollAreaScrollbarScrollEvent::PointerEnter) => Ok(Self::Interacting),\n            _ => Err(InvalidState),\n        }\n    }\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
{
  "name": "p_roving_focus",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_roving_focus.rs",
      "content": "use std::collections::HashMap;\n\nuse leptos::{ev::EventDescriptor, html::AnyElement, *};\nuse wasm_bindgen::JsCast;\nuse web_sys::{Event, FocusEvent, KeyboardEvent, MouseEvent};\n\nuse itertools::Either;\n\nuse crate::registry::primitives::{\n    p_collection::{use_collection_context, CollectionContextValue},\n    p_primitive::Primitive,\n    p_utils_create_controllable_signal::{\n        create_controllable_signal, CreateControllableSignalProps,\n    },\n    p_utils_create_id::create_id,\n    Attributes, Direction, Orientation,\n};\n\nuse super::p_collection::use_collection_item_ref;\n\n#[derive(Clone, PartialEq, Debug, Eq)]\nstruct ItemData {\n    id: String,\n    focusable: Signal<bool>,\n    active: Signal<bool>,\n}\n\nimpl Ord for ItemData {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.id.cmp(&other.id)\n    }\n}\n\nimpl PartialOrd for ItemData {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n#[derive(Clone)]\nstruct RovingContextValue {\n    orientation: Signal<Option<Orientation>>,\n    direction: Signal<Option<Direction>>,\n    should_loop: Signal<bool>,\n    current_tab_stop_id: Signal<Option<String>>,\n    on_item_focus: Callback<String>,\n    on_item_shift_tab: Callback<()>,\n    on_focusable_item_add: Callback<()>,\n    on_focusable_item_remove: Callback<()>,\n    focusable_items: RwSignal<i32>,\n}\n\n#[derive(Clone)]\nstruct OnEntryFocus;\n\nimpl EventDescriptor for OnEntryFocus {\n    const BUBBLES: bool = false;\n    type EventType = web_sys::Event;\n\n    fn name(&self) -> Oco<'static, str> {\n        \"roving_focus_group.on_entry_focus\".into()\n    }\n\n    fn event_delegation_key(&self) -> Oco<'static, str> {\n        \"$$$roving_focus_group.on_entry_focus\".into()\n    }\n}\n\n#[allow(unused_variables)]\n#[component]\npub(crate) fn RovingFocusGroup(\n    #[prop(optional, into)] orientation: MaybeProp<Orientation>,\n    #[prop(optional, into)] direction: MaybeProp<Direction>,\n    #[prop(optional, into)] should_loop: MaybeSignal<bool>,\n    #[prop(optional, into)] current_tab_stop_id: MaybeProp<String>,\n    #[prop(optional, into)] default_current_tab_stop_id: MaybeProp<String>,\n    #[prop(optional, into)] prevent_scroll_on_entry_focus: MaybeSignal<bool>,\n    #[prop(default=(|_|{}).into(), into)] on_current_tab_stop_id_change: Callback<Option<String>>,\n    #[prop(default=(|_|{}).into(), into)] on_entry_focus: Callback<Event>,\n    #[prop(default=(|_|{}).into(), into)] on_mouse_down: Callback<MouseEvent>,\n    #[prop(default=(|_|{}).into(), into)] on_focus: Callback<FocusEvent>,\n    #[prop(default=(|_|{}).into(), into)] on_blur: Callback<FocusEvent>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let collection_ref = NodeRef::<html::AnyElement>::new();\n\n    provide_context(CollectionContextValue::<ItemData, _> {\n        collection_ref,\n        item_map: RwSignal::new(HashMap::new()),\n    });\n\n    let (current_tab_stop_id, set_current_tab_stop_id) =\n        create_controllable_signal(CreateControllableSignalProps {\n            value: Signal::derive(move || current_tab_stop_id.get()),\n            default_value: Signal::derive(move || default_current_tab_stop_id.get()),\n            on_change: Callback::new(move |value| {\n                leptos::Callable::call(&on_current_tab_stop_id_change, Some(value));\n            }),\n        });\n\n    let (is_tabbing_back_out, set_is_tabbing_back_out) = create_signal(false);\n\n    let get_items = use_collection_context::<ItemData, html::AnyElement>();\n    let is_click_focus = StoredValue::new(false);\n\n    let focusable_items_count = RwSignal::new(0);\n\n    // _ = use_event_listener(collection_ref, OnEntryFocus, move |ev: web_sys::Event| {\n    //     on_entry_focus.call(ev);\n    // });\n\n    provide_context(RovingContextValue {\n        orientation: Signal::derive(move || orientation.get()),\n        direction: Signal::derive(move || direction.get()),\n        should_loop: Signal::derive(move || should_loop.get()),\n        current_tab_stop_id: Signal::derive(move || current_tab_stop_id.get()),\n        on_item_focus: Callback::new(move |item| {\n            set_current_tab_stop_id.set(item);\n        }),\n        on_item_shift_tab: Callback::new(move |_| {\n            set_is_tabbing_back_out.set(true);\n        }),\n        on_focusable_item_add: Callback::new(move |_| {\n            focusable_items_count.update(|count| {\n                *count += 1;\n            });\n        }),\n        on_focusable_item_remove: Callback::new(move |_| {\n            _ = focusable_items_count.try_update(|count| {\n                *count -= 1;\n            });\n        }),\n        focusable_items: focusable_items_count,\n    });\n\n    view! {\n        <Primitive\n            {..attrs}\n            element=html::div\n            attr:tabindex=move || {\n                if is_tabbing_back_out.get() || focusable_items_count.get() == 0 { -1 } else { 0 }\n            }\n            attr:data-orientation=move || {\n                orientation.get().map(|orientation| orientation.to_string())\n            }\n            on:mousedown=move |ev: MouseEvent| {\n                leptos::Callable::call(&on_mouse_down, ev.clone());\n                is_click_focus.set_value(true);\n            }\n            on:focus=move |ev: FocusEvent| {\n                leptos::Callable::call(&on_focus, ev.clone());\n                let is_keyboard_focus = !is_click_focus.get_value();\n                if ev.target() == ev.current_target() && is_keyboard_focus\n                    && !is_tabbing_back_out.get()\n                {\n                    let mut init = web_sys::CustomEventInit::new();\n                    init.bubbles(false).cancelable(true);\n                    let Ok(entry_focus_event) = web_sys::CustomEvent::new_with_event_init_dict(\n                        \"roving_focus_group.on_entry_focus\",\n                        &init,\n                    ) else {\n                        return;\n                    };\n                    if entry_focus_event.default_prevented() {\n                        return;\n                    }\n                    let items = get_items.get();\n                    let items = items\n                        .iter()\n                        .filter_map(|(node, item)| {\n                            item.focusable.get().then_some((node.get()?, item))\n                        });\n                    let active_item = items.clone().find(|&(_, item)| item.active.get());\n                    let current_item = items\n                        .clone()\n                        .find(|(_, item)| {\n                            current_tab_stop_id.get().map(|id| id == item.id).unwrap_or(false)\n                        });\n                    let candidate_nodes = items\n                        .map(Some)\n                        .chain([active_item, current_item].into_iter())\n                        .filter_map(|item| item.map(|(el, _)| el))\n                        .collect::<Vec<_>>();\n                    focus_first(&candidate_nodes, prevent_scroll_on_entry_focus.get());\n                }\n                is_click_focus.set_value(false);\n            }\n            on:blur=move |ev: FocusEvent| {\n                leptos::Callable::call(&on_blur, ev.clone());\n                set_is_tabbing_back_out.set(false);\n            }\n            node_ref=collection_ref\n            as_child=as_child\n        >\n            {children()}\n        </Primitive>\n    }\n}\n\n#[allow(unused_variables)]\n#[component]\npub(crate) fn RovingFocusGroupItem(\n    #[prop(optional, into)] tab_stop_id: MaybeProp<String>,\n    #[prop(optional, into)] focusable: MaybeSignal<bool>,\n    #[prop(optional, into)] active: MaybeSignal<bool>,\n    #[prop(default=(|_|{}).into(), into)] on_mouse_down: Callback<MouseEvent>,\n    #[prop(default=(|_|{}).into(), into)] on_focus: Callback<FocusEvent>,\n    #[prop(default=(|_|{}).into(), into)] on_key_down: Callback<KeyboardEvent>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let RovingContextValue {\n        orientation,\n        direction,\n        should_loop,\n        current_tab_stop_id,\n        on_item_focus,\n        on_item_shift_tab,\n        on_focusable_item_add,\n        on_focusable_item_remove,\n        focusable_items,\n    } = use_context::<RovingContextValue>()\n        .expect(\"RovingFocusGroupItem must be used in a RovingFocusGroup component\");\n\n    let id = Signal::derive(move || tab_stop_id.get().unwrap_or(create_id().get()));\n\n    use_collection_item_ref::<html::AnyElement, ItemData>(\n        node_ref,\n        ItemData {\n            id: id.get_untracked(),\n            focusable: Signal::derive(move || focusable.get()),\n            active: Signal::derive(move || active.get()),\n        },\n    );\n\n    let is_current_tab_stop = Signal::derive(move || current_tab_stop_id.get() == Some(id.get()));\n    let get_items = use_collection_context::<ItemData, html::AnyElement>();\n\n    Effect::new(move |_| {\n        if focusable.get() {\n            focusable_items.update(|items| *items += 1);\n\n            on_cleanup(move || {\n                _ = focusable_items.try_update(|items| *items -= 1);\n            });\n        }\n    });\n\n    view! {\n        <Primitive\n            {..attrs}\n            attr:tabindex=move || if is_current_tab_stop.get() { 0 } else { -1 }\n            attr:data-orientation=move || {\n                orientation.get().map(|orientation| orientation.to_string())\n            }\n            element=html::span\n            on:mousedown=move |ev: MouseEvent| {\n                leptos::Callable::call(&on_mouse_down, ev.clone());\n                if !focusable.get() {\n                    ev.prevent_default();\n                } else {\n                    leptos::Callable::call(&on_item_focus, id.get());\n                }\n            }\n            on:focus=move |ev: FocusEvent| {\n                leptos::Callable::call(&on_focus, ev.clone());\n                leptos::Callable::call(&on_item_focus, id.get());\n            }\n            on:keydown=move |ev: KeyboardEvent| {\n                leptos::Callable::call(&on_key_down, ev.clone());\n                if ev.key() == \"Tab\" && ev.shift_key() {\n                    leptos::Callable::call(&on_item_shift_tab, ());\n                    return;\n                }\n                if ev.target() != ev.current_target() {\n                    return;\n                }\n                let focus_intent = get_focus_intent(&ev, orientation.get(), direction.get());\n                if let Some(focus_intent) = focus_intent {\n                    if ev.meta_key() || ev.ctrl_key() || ev.alt_key() || ev.shift_key() {\n                        return;\n                    }\n                    ev.prevent_default();\n                    let items = get_items.get();\n                    let candidate_nodes = items\n                        .iter()\n                        .filter_map(|(node, data)| data.focusable.get().then_some(node));\n                    let candidate_nodes = if focus_intent == FocusIntent::Last\n                        || focus_intent == FocusIntent::Prev\n                    {\n                        Either::Left(candidate_nodes.rev())\n                    } else {\n                        Either::Right(candidate_nodes)\n                    };\n                    let current_index = (focus_intent == FocusIntent::Prev\n                        || focus_intent == FocusIntent::Next)\n                        .then(|| {\n                            candidate_nodes\n                                .clone()\n                                .position(|node| {\n                                    (|| {\n                                        let node = node.get()?;\n                                        Some(\n                                            ev\n                                                .current_target()?\n                                                .dyn_ref::<web_sys::Element>()?\n                                                .eq(&node),\n                                        )\n                                    })()\n                                        .unwrap_or(false)\n                                })\n                        })\n                        .flatten();\n                    let candidate_nodes = candidate_nodes\n                        .filter_map(|node| Some(node.get()?.into_any()))\n                        .collect::<Vec<_>>();\n                    let candidate_nodes = if let Some(current_index) = current_index {\n                        if should_loop.get() {\n                            let len = candidate_nodes.len();\n                            &candidate_nodes[(current_index + 1) % len..]\n                        } else {\n                            &candidate_nodes[(current_index + 1)..]\n                        }\n                    } else {\n                        &candidate_nodes\n                    };\n                    focus_first(candidate_nodes, false);\n                }\n            }\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </Primitive>\n    }\n}\n\nfn get_direction_aware_key(key: &str, direction: Option<Direction>) -> &str {\n    match direction {\n        Some(direction) => match direction {\n            Direction::LeftToRight => key,\n            _ => match key {\n                \"ArrowLeft\" => \"ArrowRight\",\n                \"ArrowRight\" => \"ArrowLeft\",\n                _ => key,\n            },\n        },\n        None => key,\n    }\n}\n\n#[derive(PartialEq, Debug)]\nenum FocusIntent {\n    First,\n    Last,\n    Prev,\n    Next,\n}\n\nfn get_focus_intent(\n    ev: &web_sys::KeyboardEvent,\n    orientation: Option<Orientation>,\n    direction: Option<Direction>,\n) -> Option<FocusIntent> {\n    let key = ev.key();\n    let key = get_direction_aware_key(&key, direction);\n\n    match orientation {\n        Some(Orientation::Vertical) if key == \"ArrowLeft\" || key == \"ArrowRight\" => None,\n        Some(Orientation::Horizontal) if key == \"ArrowUp\" || key == \"ArrowDown\" => None,\n        _ => match key {\n            \"ArrowLeft\" | \"ArrowUp\" => Some(FocusIntent::Prev),\n            \"ArrowRight\" | \"ArrowDown\" => Some(FocusIntent::Next),\n            \"PageUp\" | \"Home\" => Some(FocusIntent::First),\n            \"PageDown\" | \"End\" => Some(FocusIntent::Last),\n            _ => None,\n        },\n    }\n}\n\n#[allow(unused_variables)]\nfn focus_first(candidates: &[HtmlElement<AnyElement>], prevent_scroll: bool) {\n    let previously_focused = document().active_element();\n\n    for candidate in candidates {\n        let candidate_el: &web_sys::Element = candidate;\n\n        if Some(candidate_el) == previously_focused.as_ref() {\n            return;\n        }\n\n        _ = candidate.focus();\n\n        if document().active_element() != previously_focused {\n            return;\n        }\n    }\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
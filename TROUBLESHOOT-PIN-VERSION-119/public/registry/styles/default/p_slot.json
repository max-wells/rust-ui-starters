{
  "name": "p_slot",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_slot.rs",
      "content": "use leptos::{html::ElementDescriptor, *};\n\nuse crate::registry::primitives::Attributes;\n\n#[slot]\npub struct Slot<El>\nwhere\n    El: ElementDescriptor + Clone + 'static,\n{\n    // #[prop(attrs)]\n    attrs: Attributes,\n    #[prop(optional_no_strip)]\n    node_ref: Option<NodeRef<El>>,\n    children: Children,\n}\n\n#[allow(dead_code)]\n// pub(crate) fn merge_attrs(parent_attrs: Attributes, child_attrs: Attributes) -> Attributes {\npub(crate) fn merge_attrs(\n    parent_attrs: Attributes,\n    child_attrs: Vec<(String, Attribute)>,\n) -> Vec<(String, Attribute)> {\n    let mut cloned_parent_attrs = parent_attrs.clone();\n    let mut child_attrs = child_attrs\n        .into_iter()\n        .map(|(name, child_attr)| {\n            if let Some((_, parent_attr)) = parent_attrs.iter().find(|attr| attr.0 == name) {\n                if let Some(position) = cloned_parent_attrs.iter().position(|item| item.0 == name) {\n                    cloned_parent_attrs.remove(position);\n                }\n\n                match name.as_str() {\n                    \"class\" => (name, merge_attr(parent_attr, &child_attr)),\n                    \"style\" => (name, merge_styles(parent_attr, &child_attr)),\n                    _ => (name, child_attr),\n                }\n            } else {\n                (name, child_attr)\n            }\n        })\n        .collect::<Vec<_>>();\n\n    child_attrs.extend(\n        cloned_parent_attrs\n            .iter()\n            .map(|(name, attr)| (name.to_string(), attr.clone())),\n    );\n\n    child_attrs\n}\n\nfn merge_attr(first: &Attribute, second: &Attribute) -> Attribute {\n    if let Attribute::Fn(first) = first {\n        return merge_attr(&first(), second);\n    }\n\n    if let Attribute::Fn(second) = second {\n        return merge_attr(first, &second());\n    }\n\n    match (first, second) {\n        (Attribute::String(first), Attribute::String(second)) => {\n            format!(\"{} {}\", first.trim(), second.trim()).into_attribute()\n        }\n        _ => second.clone(),\n    }\n}\n\nfn merge_styles(first: &Attribute, second: &Attribute) -> Attribute {\n    if let Attribute::Fn(first) = first {\n        return merge_styles(&first(), second);\n    }\n\n    if let Attribute::Fn(second) = second {\n        return merge_styles(first, &second());\n    }\n\n    match (first, second) {\n        (Attribute::String(first), Attribute::String(second)) => {\n            format!(\"{}; {}\", first.trim(), second.trim()).into_attribute()\n        }\n        _ => second.clone(),\n    }\n}\n\n#[test]\nfn merged_attrs() {\n    assert_eq!(\n        merge_attrs(\n            vec![(\n                \"class\",\n                Attribute::String(\"text-blue-500 outline-none\".into())\n            )],\n            vec![(\n                \"class\".to_string(),\n                Attribute::Fn(std::rc::Rc::new(|| \"bg-neutral-500\".into_attribute())) // Attribute::String(\"bg-neutral-500\".into())\n            )]\n        ),\n        vec![(\n            \"class\".to_string(),\n            Attribute::String(\"text-blue-500 outline-none bg-neutral-500\".into())\n        )]\n    )\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
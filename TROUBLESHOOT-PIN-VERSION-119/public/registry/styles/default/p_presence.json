{
  "name": "p_presence",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_presence.rs",
      "content": "use leptos::{\n    ev::{animationcancel, animationend, animationstart},\n    html::AnyElement,\n    *,\n};\nuse leptos_use::use_event_listener;\nuse wasm_bindgen::{JsCast, JsValue};\nuse web_sys::{js_sys::Object, AnimationEvent, CssStyleDeclaration};\n\nuse derive_more::{Deref, From};\n\nuse crate::registry::primitives::p_utils_create_state_machine::{\n    create_state_machine, InvalidState, MachineState,\n};\n\n#[derive(Deref, From, Clone)]\nstruct StyleDeclaration(CssStyleDeclaration);\n\nimpl Default for StyleDeclaration {\n    fn default() -> Self {\n        Self(CssStyleDeclaration::from(JsValue::from(Object::new())))\n    }\n}\n\npub(crate) fn create_presence(\n    is_present: Signal<bool>,\n    node_ref: NodeRef<AnyElement>,\n) -> Signal<bool> {\n    let styles = StoredValue::<Option<StyleDeclaration>>::new(None);\n    let prev_present = StoredValue::new(is_present.get_untracked());\n    let prev_animation_name = StoredValue::new(String::from(\"none\"));\n\n    let initial = Signal::derive(move || {\n        if is_present.get() {\n            PresenceState::Mounted\n        } else {\n            PresenceState::Unmounted\n        }\n    });\n\n    let (state, send) = create_state_machine(initial.into());\n\n    Effect::new(move |_| {\n        if let Some(node) = node_ref.get() {\n            if let Ok(Some(computed_style)) = window().get_computed_style(&node) {\n                styles.set_value(Some(computed_style.into()));\n            }\n        }\n    });\n\n    Effect::new(move |_| {\n        let current_animation_name = styles\n            .get_value()\n            .unwrap_or_default()\n            .get_property_value(\"animation-name\")\n            .unwrap_or(\"none\".to_string());\n\n        prev_animation_name.set_value(match state.get() {\n            PresenceState::Mounted => current_animation_name,\n            _ => \"none\".to_string(),\n        });\n    });\n\n    Effect::new(move |_| {\n        let was_present = prev_present.get_value();\n        let has_present_changed = was_present != is_present.get();\n\n        if !has_present_changed {\n            return;\n        }\n\n        if styles.get_value().is_none() {\n            styles.set_value(Some(StyleDeclaration::default()));\n        }\n\n        let styles = styles.get_value().unwrap_or_default();\n\n        let current_animation_name = styles\n            .get_property_value(\"animation-name\")\n            .unwrap_or(\"none\".to_string());\n\n        if is_present.get() {\n            leptos::Callable::call(&send, PresenceEvent::Mount);\n        } else if current_animation_name == \"none\"\n            || styles\n                .get_property_value(\"display\")\n                .map(|display| display == \"none\")\n                .unwrap_or(false)\n        {\n            leptos::Callable::call(&send, PresenceEvent::Unmount);\n        } else {\n            let is_animating = prev_animation_name.get_value() != current_animation_name;\n\n            if was_present && is_animating {\n                leptos::Callable::call(&send, PresenceEvent::AnimationOut);\n            } else {\n                leptos::Callable::call(&send, PresenceEvent::Unmount);\n            }\n        }\n\n        prev_present.set_value(is_present.get());\n    });\n\n    Effect::new(move |_| {\n        let Some(node) = node_ref.get() else {\n            leptos::Callable::call(&send, PresenceEvent::AnimationEnd);\n            return;\n        };\n\n        if node.is_null() {\n            leptos::Callable::call(&send, PresenceEvent::AnimationEnd);\n            return;\n        }\n\n        let handle_start_node = node.clone();\n        _ = use_event_listener(node_ref, animationstart, move |ev: AnimationEvent| {\n            let Some(target) = ev.target() else {\n                return;\n            };\n\n            let Some(target_el) = target.dyn_ref::<web_sys::Element>() else {\n                return;\n            };\n\n            if target_el.eq(&handle_start_node) {\n                if styles.get_value().is_none() {\n                    styles.set_value(Some(StyleDeclaration::default()));\n                }\n\n                prev_animation_name.set_value(\n                    styles\n                        .get_value()\n                        .unwrap_or_default()\n                        .get_property_value(\"animation-name\")\n                        .unwrap_or(\"none\".to_string()),\n                );\n            }\n        });\n\n        let handle_end_node = node.clone();\n        let handle_animation_end = move |ev: AnimationEvent| {\n            if styles.get_value().is_none() {\n                styles.set_value(Some(StyleDeclaration::default()));\n            }\n\n            let current_animation_name = styles\n                .get_value()\n                .unwrap_or_default()\n                .get_property_value(\"animation-name\")\n                .unwrap_or(\"none\".to_string());\n\n            let is_current_animation = current_animation_name.contains(&ev.animation_name());\n\n            let Some(target) = ev.target() else {\n                return;\n            };\n\n            let Some(target_el) = target.dyn_ref::<web_sys::Element>() else {\n                return;\n            };\n\n            if target_el.eq(&handle_end_node) && is_current_animation {\n                leptos::Callable::call(&send, PresenceEvent::AnimationEnd);\n            }\n        };\n\n        _ = use_event_listener(node_ref, animationend, handle_animation_end.clone());\n        _ = use_event_listener(node_ref, animationcancel, handle_animation_end);\n    });\n\n    Signal::derive(move || {\n        state.get() == PresenceState::Mounted || state.get() == PresenceState::UnmountSuspended\n    })\n}\n\n#[derive(Debug, Clone, PartialEq)]\nenum PresenceState {\n    Mounted,\n    UnmountSuspended,\n    Unmounted,\n}\n\n#[derive(Debug, Clone, Copy)]\nenum PresenceEvent {\n    Mount,\n    Unmount,\n    AnimationOut,\n    AnimationEnd,\n}\n\nimpl MachineState<Self, PresenceEvent> for PresenceState {\n    fn send(&self, event: PresenceEvent) -> Result<Self, InvalidState> {\n        match (self, event) {\n            (Self::Mounted, PresenceEvent::Unmount) => Ok(Self::Unmounted),\n            (Self::Mounted, PresenceEvent::AnimationOut) => Ok(Self::UnmountSuspended),\n            (Self::Unmounted, PresenceEvent::Mount) => Ok(Self::Mounted),\n            (Self::UnmountSuspended, PresenceEvent::AnimationEnd) => Ok(Self::Unmounted),\n            (Self::UnmountSuspended, PresenceEvent::Mount) => Ok(Self::Mounted),\n            _ => Err(InvalidState),\n        }\n    }\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
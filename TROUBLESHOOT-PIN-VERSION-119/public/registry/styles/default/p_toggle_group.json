{
  "name": "p_toggle_group",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_toggle_group.rs",
      "content": "use leptos::{html::AnyElement, *};\n\nuse crate::{\n    registry::primitives::{\n        p_primitive::Primitive,\n        p_roving_focus::{RovingFocusGroup, RovingFocusGroupItem},\n        p_toggle::PrimitiveToggleRoot,\n        p_utils_create_controllable_signal::{\n            create_controllable_signal, CreateControllableSignalProps,\n        },\n        Attributes,\n    },\n    registry::primitives::{Direction, Orientation},\n};\n\npub enum ToggleGroupKind {\n    Single {\n        value: MaybeProp<String>,\n        default_value: MaybeProp<String>,\n        on_value_change: Option<Callback<String>>,\n    },\n    Multiple {\n        value: MaybeProp<Vec<String>>,\n        default_value: MaybeProp<Vec<String>>,\n        on_value_change: Option<Callback<Vec<String>>>,\n    },\n}\n\npub struct ToggleGroupSingle;\npub struct ToggleGroupMultiple;\n\nimpl ToggleGroupSingle {\n    pub fn none() -> Option<String> {\n        None\n    }\n}\n\nimpl ToggleGroupMultiple {\n    pub fn none() -> Option<Vec<String>> {\n        None\n    }\n}\n\n#[component]\npub fn ToggleGroupRoot(\n    kind: ToggleGroupKind,\n\n    #[prop(optional, into)] disabled: MaybeSignal<bool>,\n    #[prop(default=true.into(), into)] roving_focus: MaybeSignal<bool>,\n    #[prop(default=true.into(), into)] should_loop: MaybeSignal<bool>,\n    #[prop(optional, into)] orientation: MaybeSignal<Orientation>,\n    #[prop(optional, into)] direction: MaybeSignal<Direction>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    match kind {\n        ToggleGroupKind::Single {\n            value,\n            default_value,\n            on_value_change,\n        } => view! {\n            <ToggleGroupSingleImpl\n                disabled=disabled\n                roving_focus=roving_focus\n                should_loop=should_loop\n                orientation=orientation\n                direction=direction\n                value=value\n                default_value=default_value\n                on_value_change=on_value_change.unwrap_or((|_| {}).into())\n                node_ref=node_ref\n                attrs=attrs\n                as_child=as_child\n            >\n                {children()}\n            </ToggleGroupSingleImpl>\n        },\n        ToggleGroupKind::Multiple {\n            value,\n            default_value,\n            on_value_change,\n        } => view! {\n            <ToggleGroupMultipleImpl\n                disabled=disabled\n                roving_focus=roving_focus\n                should_loop=should_loop\n                orientation=orientation\n                direction=direction\n                value=value\n                default_value=default_value\n                on_value_change=on_value_change.unwrap_or((|_| {}).into())\n                node_ref=node_ref\n                attrs=attrs\n                as_child=as_child\n            >\n                {children()}\n            </ToggleGroupMultipleImpl>\n        },\n    }\n}\n\n#[derive(Clone, PartialEq)]\nenum ToggleGroupValueKind {\n    Single,\n    Multiple,\n}\n\n#[derive(Clone)]\nstruct ToggleGroupValueContextValue {\n    kind: ToggleGroupValueKind,\n    value: Signal<Vec<String>>,\n    on_item_activate: Callback<String>,\n    on_item_deactivate: Callback<String>,\n}\n\n#[component]\nfn ToggleGroupSingleImpl(\n    disabled: MaybeSignal<bool>,\n    roving_focus: MaybeSignal<bool>,\n    should_loop: MaybeSignal<bool>,\n    orientation: MaybeSignal<Orientation>,\n    direction: MaybeSignal<Direction>,\n    #[prop(optional, into)] value: MaybeProp<String>,\n    #[prop(optional, into)] default_value: MaybeProp<String>,\n\n    on_value_change: Callback<String>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let (value, set_value) = create_controllable_signal(CreateControllableSignalProps {\n        value: Signal::derive(move || value.get()),\n        default_value: Signal::derive(move || default_value.get()),\n        on_change: on_value_change,\n    });\n\n    let set_on_item_activate = set_value.clone();\n    let set_on_item_deactivate = set_value.clone();\n    provide_context(ToggleGroupValueContextValue {\n        kind: ToggleGroupValueKind::Single,\n        value: Signal::derive(move || value.get().map(|value| vec![value]).unwrap_or_default()),\n        on_item_activate: Callback::new(move |item| {\n            set_on_item_activate.set(item);\n        }),\n        on_item_deactivate: Callback::new(move |_| set_on_item_deactivate.set(String::new())),\n    });\n\n    view! {\n        <ToggleGroup\n            disabled=disabled\n            roving_focus=roving_focus\n            should_loop=should_loop\n            orientation=orientation\n            direction=direction\n            node_ref=node_ref\n            attrs=attrs\n            as_child=as_child\n        >\n            {children()}\n        </ToggleGroup>\n    }\n}\n\n#[component]\nfn ToggleGroupMultipleImpl(\n    disabled: MaybeSignal<bool>,\n    roving_focus: MaybeSignal<bool>,\n    should_loop: MaybeSignal<bool>,\n    orientation: MaybeSignal<Orientation>,\n    direction: MaybeSignal<Direction>,\n    #[prop(optional, into)] value: MaybeProp<Vec<String>>,\n    #[prop(optional, into)] default_value: MaybeProp<Vec<String>>,\n\n    on_value_change: Callback<Vec<String>>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let (value, set_value) = create_controllable_signal(CreateControllableSignalProps {\n        value: Signal::derive(move || value.get()),\n        default_value: Signal::derive(move || default_value.get()),\n        on_change: on_value_change,\n    });\n\n    let set_on_item_activate = set_value.clone();\n    let set_on_item_deactivate = set_value.clone();\n    provide_context(ToggleGroupValueContextValue {\n        kind: ToggleGroupValueKind::Multiple,\n        value: Signal::derive(move || value.get().unwrap_or_default()),\n        on_item_activate: Callback::new(move |item| {\n            set_on_item_activate.update(|value| {\n                if let Some(value) = value {\n                    value.push(item);\n                } else {\n                    *value = Some(vec![item]);\n                }\n            });\n        }),\n        on_item_deactivate: Callback::new(move |item| {\n            set_on_item_deactivate.update(|value| {\n                if let Some(value) = value {\n                    *value = value\n                        .iter()\n                        .filter_map(|value| (*value != item).then_some(value.to_string()))\n                        .collect::<Vec<_>>();\n                } else {\n                    *value = Some(vec![]);\n                }\n            })\n        }),\n    });\n\n    view! {\n        <ToggleGroup\n            disabled=disabled\n            roving_focus=roving_focus\n            should_loop=should_loop\n            orientation=orientation\n            direction=direction\n            node_ref=node_ref\n            attrs=attrs\n            as_child=as_child\n        >\n            {children()}\n        </ToggleGroup>\n    }\n}\n\n#[derive(Clone)]\nstruct ToggleGroupStateContextValue {\n    disabled: Signal<bool>,\n    roving_focus: Signal<bool>,\n}\n\n#[component]\nfn ToggleGroup(\n    disabled: MaybeSignal<bool>,\n    roving_focus: MaybeSignal<bool>,\n    should_loop: MaybeSignal<bool>,\n    orientation: MaybeSignal<Orientation>,\n    direction: MaybeSignal<Direction>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    provide_context(ToggleGroupStateContextValue {\n        roving_focus: Signal::derive(move || roving_focus.get()),\n        disabled: Signal::derive(move || disabled.get()),\n    });\n\n    let children = StoredValue::new(children);\n    let attrs = StoredValue::new(attrs);\n\n    view! {\n        <Show\n            when=move || roving_focus.get()\n            fallback=move || {\n                view! {\n                    <Primitive\n                        {..attrs.get_value()}\n                        attr:role=\"group\"\n                        attr:dir=move || direction.get().to_string()\n                        element=html::div\n                        node_ref=node_ref\n                        as_child=as_child\n                    >\n                        {children.with_value(|children| children())}\n                    </Primitive>\n                }\n            }\n        >\n            <RovingFocusGroup\n                as_child=true\n                orientation=Signal::derive(move || orientation.get())\n                direction=Signal::derive(move || direction.get())\n                should_loop=Signal::derive(move || should_loop.get())\n            >\n                <Primitive\n                    {..attrs.get_value()}\n                    attr:role=\"group\"\n                    attr:dir=move || direction.get().to_string()\n                    element=html::div\n                    node_ref=node_ref\n                    as_child=as_child\n                >\n                    {children.with_value(|children| children())}\n                </Primitive>\n            </RovingFocusGroup>\n        </Show>\n    }\n}\n\n#[component]\npub fn ToggleGroupItem(\n    #[prop(optional, into)] disabled: MaybeSignal<bool>,\n    #[prop(into)] value: MaybeSignal<String>,\n\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n\n    #[prop(optional)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let ToggleGroupValueContextValue {\n        kind,\n        value: context_value,\n        on_item_activate,\n        on_item_deactivate,\n    } = use_context().expect(\"ToggleGroupItem must be in a ToggleGroupRoot component\");\n    let ToggleGroupStateContextValue {\n        disabled: context_disabled,\n        roving_focus,\n    } = use_context().expect(\"ToggleGroupItem must be in a ToggleGroupRoot component\");\n\n    let is_pressed_value = value.clone();\n    let is_pressed = Signal::derive(move || context_value.get().contains(&is_pressed_value.get()));\n    let is_disabled = Signal::derive(move || context_disabled.get() || disabled.get());\n    let focusable = Signal::derive(move || !is_disabled.get());\n\n    let children = StoredValue::new(children);\n    let kind = StoredValue::new(kind);\n    let attrs = StoredValue::new(attrs);\n    let value = StoredValue::new(value);\n\n    view! {\n        <Show\n            when=move || roving_focus.get()\n            fallback=move || {\n                view! {\n                    <PrimitiveToggleRoot\n                        {..attrs.get_value()}\n                        attr:role=move || {\n                            (kind.get_value() == ToggleGroupValueKind::Single).then_some(\"radio\")\n                        }\n                        attr:aria-checked=move || {\n                            (kind.get_value() == ToggleGroupValueKind::Single)\n                                .then_some(is_pressed.get().to_string())\n                        }\n                        disabled=is_disabled\n                        pressed=is_pressed\n                        on_pressed_changed=Callback::new(move |pressed| {\n                            if pressed {\n                                leptos::Callable::call(&on_item_activate, value.get_value().get());\n                            } else {\n                                leptos::Callable::call(\n                                    &on_item_deactivate,\n                                    value.get_value().get(),\n                                );\n                            }\n                        })\n                        node_ref=node_ref\n                        as_child=as_child\n                    >\n                        {children.with_value(|children| children())}\n                    </PrimitiveToggleRoot>\n                }\n            }\n        >\n            <RovingFocusGroupItem as_child=true focusable=focusable active=is_pressed>\n                <PrimitiveToggleRoot\n                    {..attrs.get_value()}\n                    attr:role=move || {\n                        (kind.get_value() == ToggleGroupValueKind::Single).then_some(\"radio\")\n                    }\n                    attr:aria-checked=move || {\n                        (kind.get_value() == ToggleGroupValueKind::Single)\n                            .then_some(is_pressed.get().to_string())\n                    }\n                    disabled=is_disabled\n                    pressed=is_pressed\n                    on_pressed_changed=Callback::new(move |pressed| {\n                        if pressed {\n                            leptos::Callable::call(&on_item_activate, value.get_value().get());\n                        } else {\n                            leptos::Callable::call(&on_item_deactivate, value.get_value().get());\n                        }\n                    })\n                    node_ref=node_ref\n                    as_child=as_child\n                >\n                    {children.with_value(|children| children())}\n                </PrimitiveToggleRoot>\n            </RovingFocusGroupItem>\n        </Show>\n    }\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
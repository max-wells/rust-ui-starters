{
  "name": "p_collapsible",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_collapsible.rs",
      "content": "use leptos::{html::AnyElement, leptos_dom::helpers::AnimationFrameRequestHandle, *};\nuse wasm_bindgen::JsValue;\nuse web_sys::{js_sys::Object, CssStyleDeclaration, MouseEvent};\n\nuse crate::registry::primitives::{\n    p_presence::create_presence,\n    p_primitive::Primitive,\n    p_utils_create_controllable_signal::{\n        create_controllable_signal, CreateControllableSignalProps,\n    },\n    p_utils_create_id::create_id,\n    Attributes,\n};\n\n#[derive(Clone)]\nstruct CollapsibleContextValue {\n    content_id: Signal<String>,\n    disabled: Signal<bool>,\n    open: Signal<bool>,\n    on_open_toggle: Callback<()>,\n}\n\n#[allow(unused_variables)]\n#[component]\npub fn PrimitiveCollapsibleRoot(\n    #[prop(optional, into)] open: MaybeSignal<bool>,\n    #[prop(optional, into)] default_open: MaybeSignal<bool>,\n    #[prop(optional, into)] disabled: MaybeSignal<bool>,\n    #[prop(default=(|_|{}).into(), into)] on_open_change: Callback<bool>,\n    #[prop(default=(|_|{}).into(), into)] on_click: Callback<MouseEvent>,\n    #[prop(optional, into)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let (open, set_open) = create_controllable_signal(CreateControllableSignalProps {\n        value: Signal::derive(move || Some(open.get())),\n        default_value: Signal::derive(move || Some(default_open.get())),\n        on_change: Callback::new(move |value| {\n            leptos::Callable::call(&on_open_change, value);\n        }),\n    });\n\n    provide_context(CollapsibleContextValue {\n        open: Signal::derive(move || open.get().unwrap_or(false)),\n        disabled: Signal::derive(move || disabled.get()),\n        content_id: create_id(),\n        on_open_toggle: Callback::new(move |_| {\n            set_open.update(|open| *open = Some(!open.unwrap_or(false)))\n        }),\n    });\n\n    view! {\n        <Primitive\n            {..attrs}\n            attr:data-state=move || { if open.get().unwrap_or(false) { \"open\" } else { \"closed\" } }\n            attr:data-disabled=disabled\n            element=html::div\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </Primitive>\n    }\n}\n\n#[component]\npub fn PrimitiveCollapsibleTrigger(\n    #[prop(default=(|_|{}).into(), into)] on_click: Callback<MouseEvent>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let CollapsibleContextValue {\n        content_id,\n        disabled,\n        open,\n        on_open_toggle,\n    } = use_context::<CollapsibleContextValue>()\n        .expect(\"CollapsibleTrigger must be used in a CollapsibleRoot component\");\n\n    view! {\n        <Primitive\n            {..attrs}\n            attr:aria-controls=content_id\n            attr:aria-expanded=open\n            attr:data-state=move || if open.get() { \"open\" } else { \"closed\" }\n            attr:data-disabled=disabled\n            attr:disabled=disabled\n            element=html::button\n            on:click=move |ev: MouseEvent| {\n                leptos::Callable::call(&on_click, ev);\n                leptos::Callable::call(&on_open_toggle, ());\n            }\n            node_ref=node_ref\n            as_child=as_child\n        >\n            {children()}\n        </Primitive>\n    }\n}\n\n#[component]\npub fn PrimitiveCollapsibleContent(\n    #[prop(optional, into)] force_mount: MaybeSignal<bool>,\n    #[prop(optional)] node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let CollapsibleContextValue {\n        open, ..\n    } = use_context::<CollapsibleContextValue>()\n        .expect(\"CollapsibleContent must be used in a CollapsibleRoot component\");\n\n    let is_present = Signal::derive(move || open.get() || force_mount.get());\n\n    let presence = create_presence(is_present, node_ref);\n    let children = StoredValue::new(children);\n\n    view! {\n        <Show when=move || presence.get()>\n            <PrimitiveCollapsibleContentImpl\n                is_present=presence\n                node_ref=node_ref\n                attrs=attrs.clone()\n                as_child=as_child\n            >\n                {children.with_value(|children| children())}\n            </PrimitiveCollapsibleContentImpl>\n        </Show>\n    }\n}\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                     ✨ FUNCTIONS ✨                        */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n#[component]\nfn PrimitiveCollapsibleContentImpl(\n    is_present: Signal<bool>,\n    node_ref: NodeRef<AnyElement>,\n    #[prop(attrs)] attrs: Attributes,\n    children: ChildrenFn,\n    #[prop(optional, into)] as_child: MaybeProp<bool>,\n) -> impl IntoView {\n    let CollapsibleContextValue {\n        content_id,\n        disabled,\n        open,\n        ..\n    } = use_context::<CollapsibleContextValue>()\n        .expect(\"CollapsibleContentImpl must be used in a CollapsibleRoot component\");\n\n    let is_open = Signal::derive(move || open.get() || is_present.get());\n    let is_mount_animation_prevented = StoredValue::new(is_open.get_untracked());\n\n    let original_styles = StoredValue::<Option<CssStyleDeclaration>>::new(None);\n    let animation_frame_handle = StoredValue::<Option<AnimationFrameRequestHandle>>::new(None);\n\n    Effect::new(move |_| {\n        if let Ok(handle) = request_animation_frame_with_handle(move || {\n            is_mount_animation_prevented.set_value(false);\n        }) {\n            animation_frame_handle.set_value(Some(handle));\n        }\n    });\n\n    on_cleanup(move || {\n        if let Some(handle) = animation_frame_handle.get_value() {\n            handle.cancel();\n        }\n    });\n\n    let rect_size = Signal::derive(move || {\n        let mut node = node_ref.get()?;\n        let node_style = window().get_computed_style(&node).ok()?;\n\n        if original_styles.get_value().is_none() {\n            let new_styles = CssStyleDeclaration::from(JsValue::from(Object::new()));\n\n            if let Some(node_style) = node_style {\n                if let Ok(transition_duration) =\n                    node_style.get_property_value(\"transition-duration\")\n                {\n                    _ = new_styles.set_property(\"transition-duration\", &transition_duration);\n                }\n\n                if let Ok(animation_name) = node_style.get_property_value(\"animation-name\") {\n                    _ = new_styles.set_property(\"animation-name\", &animation_name);\n                }\n            }\n\n            original_styles.set_value(Some(new_styles));\n        }\n\n        logging::log!(\"removing animations\");\n        node = node\n            .style(\"transition-duration\", \"0s\")\n            .style(\"animation-name\", \"none\");\n\n        let rect = node.get_bounding_client_rect();\n\n        if !is_mount_animation_prevented.get_value() {\n            logging::log!(\"adding back animations\");\n\n            _ = node\n                .style(\n                    \"transition-duration\",\n                    original_styles\n                        .get_value()\n                        .and_then(|styles| styles.get_property_value(\"transition-duration\").ok()),\n                )\n                .style(\n                    \"animation-name\",\n                    original_styles\n                        .get_value()\n                        .and_then(|styles| styles.get_property_value(\"animation-name\").ok()),\n                );\n        }\n\n        logging::log!(\"{} {}\", rect.width(), rect.height());\n\n        Some((rect.width(), rect.height()))\n    });\n\n    let present_state = Signal::derive(move || {\n        rect_size\n            .get()\n            .map(|_| is_present.get())\n            .unwrap_or(is_present.get())\n    });\n\n    Effect::new(move |_| {\n        let Some(node) = node_ref.get() else {\n            return;\n        };\n\n        let Some((width, height)) = rect_size.get() else {\n            return;\n        };\n\n        _ = node\n            .style(\n                \"--primitive-collapsible-content-width\",\n                format!(\"{width}px\"),\n            )\n            .style(\n                \"--primitive-collapsible-content-height\",\n                format!(\"{height}px\"),\n            );\n    });\n\n    let children = StoredValue::new(children);\n\n    view! {\n        <Primitive\n            {..attrs}\n            attr:data-state=move || { if open.get() { \"open\" } else { \"closed\" } }\n            attr:data-disabled=disabled\n            attr:id=content_id\n            attr:hidden=move || !(is_open.get() || present_state.get())\n            element=html::div\n            node_ref=node_ref\n            as_child=as_child\n        >\n            <Show when=move || is_open.get()>{children.with_value(|children| children())}</Show>\n        </Primitive>\n    }\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}
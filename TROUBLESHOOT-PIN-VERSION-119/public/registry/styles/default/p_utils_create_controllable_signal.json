{
  "name": "p_utils_create_controllable_signal",
  "cargo_dependencies": [],
  "files": [
    {
      "name": "p_utils_create_controllable_signal.rs",
      "content": "use leptos::*;\n\npub struct CreateControllableSignalProps<T: Clone + PartialEq + 'static> {\n    pub value: Signal<Option<T>>,\n    pub default_value: Signal<Option<T>>,\n    pub on_change: Callback<T>,\n}\n\n#[derive(Clone, Copy)]\npub struct WriteControllableSignal<T: Clone + 'static> {\n    is_controlled: Signal<bool>,\n    value: Signal<Option<T>>,\n    pub(crate) set_uncontrolled_value: WriteSignal<Option<T>>,\n    pub(crate) on_change: Callback<Option<T>>,\n}\n\nimpl<T: Clone + 'static> WriteControllableSignal<T> {\n    pub fn set(&self, value: T) {\n        if self.is_controlled.get() {\n            leptos::Callable::call(&self.on_change, Some(value));\n        } else {\n            let set_uncontrolled_value = self.set_uncontrolled_value;\n            let cloned_value = value.clone();\n\n            // request_animation_frame(move || {\n            set_uncontrolled_value.set(Some(cloned_value));\n            // self.set_uncontrolled_value.set(Some(cloned_value));\n            // });\n            leptos::Callable::call(&self.on_change, Some(value));\n        }\n    }\n\n    pub fn update(&self, callback: impl FnOnce(&mut Option<T>)) {\n        if self.is_controlled.get() {\n            let mut value = self.value.get();\n\n            callback(&mut value);\n\n            leptos::Callable::call(&self.on_change, value);\n        } else {\n            self.set_uncontrolled_value.update(|value| {\n                callback(value);\n                leptos::Callable::call(&self.on_change, value.clone());\n            });\n        }\n    }\n}\n\npub fn create_controllable_signal<T: Clone + PartialEq + 'static>(\n    CreateControllableSignalProps {\n        value,\n        default_value,\n        on_change,\n    }: CreateControllableSignalProps<T>,\n) -> (Signal<Option<T>>, WriteControllableSignal<T>) {\n    let (uncontrolled_value, set_uncontrolled_value) =\n        create_uncontrolled_signal(CreateUncontrolledSignalProps {\n            default_value,\n            on_change,\n        });\n\n    let is_controlled = Signal::derive(move || value.get().is_some());\n    let value = Signal::derive(move || {\n        if is_controlled.get() {\n            value.get()\n        } else {\n            uncontrolled_value.get()\n        }\n    });\n\n    (\n        value,\n        WriteControllableSignal {\n            is_controlled,\n            value,\n            set_uncontrolled_value,\n            on_change: Callback::new(move |value| {\n                if let Some(value) = value {\n                    leptos::Callable::call(&on_change, value);\n                }\n            }),\n        },\n    )\n}\n\npub(crate) struct CreateUncontrolledSignalProps<T: Clone + 'static> {\n    default_value: Signal<Option<T>>,\n    on_change: Callback<T>,\n}\n\nfn create_uncontrolled_signal<T: Clone + PartialEq + 'static>(\n    CreateUncontrolledSignalProps {\n        default_value,\n        on_change,\n    }: CreateUncontrolledSignalProps<T>,\n) -> (ReadSignal<Option<T>>, WriteSignal<Option<T>>) {\n    let (uncontrolled_value, set_uncontrolled_value) = create_signal(default_value.get_untracked());\n\n    let prev_value = StoredValue::new(uncontrolled_value.get_untracked());\n\n    Effect::new(move |_| {\n        if prev_value.get_value() != uncontrolled_value.get() {\n            if let Some(value) = uncontrolled_value.get() {\n                leptos::Callable::call(&on_change, value);\n            }\n\n            prev_value.set_value(uncontrolled_value.get());\n        }\n    });\n\n    (uncontrolled_value, set_uncontrolled_value)\n}\n"
    }
  ],
  "type": "components:primitives/",
  "type_short": "components:primitives"
}